// Code generated from ./parser/Solidity.g4 by ANTLR 4.10.1. DO NOT EDIT.

package parser // Solidity

import (
	"fmt"
	"strconv"
  "sync"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}


type SolidityParser struct {
	*antlr.BaseParser
}

var solidityParserStaticData struct {
  once                   sync.Once
  serializedATN          []int32
  literalNames           []string
  symbolicNames          []string
  ruleNames              []string
  predictionContextCache *antlr.PredictionContextCache
  atn                    *antlr.ATN
  decisionToDFA          []*antlr.DFA
}

func solidityParserInit() {
  staticData := &solidityParserStaticData
  staticData.literalNames = []string{
    "", "'pragma'", "';'", "'^'", "'~'", "'>='", "'>'", "'<'", "'<='", "'='", 
    "'import'", "'as'", "'*'", "'from'", "'{'", "','", "'}'", "'abstract'", 
    "'contract'", "'interface'", "'library'", "'is'", "'('", "')'", "'override'", 
    "'using'", "'for'", "'struct'", "'modifier'", "'function'", "'returns'", 
    "'event'", "'enum'", "'['", "']'", "'.'", "'mapping'", "'=>'", "'memory'", 
    "'storage'", "'calldata'", "'if'", "'else'", "'try'", "'catch'", "'while'", 
    "'assembly'", "'do'", "'return'", "'throw'", "'emit'", "'var'", "'address'", 
    "'bool'", "'string'", "'byte'", "'++'", "'--'", "'new'", "':'", "'+'", 
    "'-'", "'after'", "'delete'", "'!'", "'**'", "'/'", "'%'", "'<<'", "'>>'", 
    "'&'", "'|'", "'=='", "'!='", "'&&'", "'||'", "'?'", "'|='", "'^='", 
    "'&='", "'<<='", "'>>='", "'+='", "'-='", "'*='", "'/='", "'%='", "'let'", 
    "':='", "'=:'", "'switch'", "'case'", "'default'", "", "", "", "", "", 
    "", "", "", "", "", "", "'anonymous'", "'break'", "'constant'", "'immutable'", 
    "'continue'", "'leave'", "'external'", "'indexed'", "'internal'", "'payable'", 
    "'private'", "'public'", "'virtual'", "'pure'", "'type'", "'view'", 
    "'constructor'", "'fallback'", "'receive'",
  }
  staticData.symbolicNames = []string{
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "Int", "Uint", "Byte", "Fixed", "Ufixed", 
    "BooleanLiteral", "DecimalNumber", "HexNumber", "NumberUnit", "HexLiteralFragment", 
    "ReservedKeyword", "AnonymousKeyword", "BreakKeyword", "ConstantKeyword", 
    "ImmutableKeyword", "ContinueKeyword", "LeaveKeyword", "ExternalKeyword", 
    "IndexedKeyword", "InternalKeyword", "PayableKeyword", "PrivateKeyword", 
    "PublicKeyword", "VirtualKeyword", "PureKeyword", "TypeKeyword", "ViewKeyword", 
    "ConstructorKeyword", "FallbackKeyword", "ReceiveKeyword", "Identifier", 
    "StringLiteralFragment", "VersionLiteral", "WS", "COMMENT", "LINE_COMMENT",
  }
  staticData.ruleNames = []string{
    "sourceUnit", "pragmaDirective", "pragmaName", "pragmaValue", "version", 
    "versionConstraint", "versionOperator", "importDirective", "importDeclaration", 
    "contractDefinition", "inheritanceSpecifier", "contractPart", "stateVariableDeclaration", 
    "overrideSpecifier", "usingForDeclaration", "structDefinition", "modifierDefinition", 
    "functionDefinition", "functionDescriptor", "returnParameters", "modifierList", 
    "modifierInvocation", "eventDefinition", "enumDefinition", "enumValue", 
    "parameterList", "parameter", "eventParameterList", "eventParameter", 
    "variableDeclaration", "typeName", "userDefinedTypeName", "mapping", 
    "functionTypeName", "storageLocation", "stateMutability", "block", "statement", 
    "expressionStatement", "ifStatement", "tryStatement", "catchClause", 
    "whileStatement", "forStatement", "simpleStatement", "inlineAssemblyStatement", 
    "doWhileStatement", "continueStatement", "breakStatement", "returnStatement", 
    "throwStatement", "emitStatement", "variableDeclarationStatement", "variableDeclarationList", 
    "identifierList", "elementaryTypeName", "expression", "primaryExpression", 
    "expressionList", "nameValueList", "nameValue", "functionCallArguments", 
    "functionCall", "tupleExpression", "typeNameExpression", "assemblyItem", 
    "assemblyBlock", "assemblyExpression", "assemblyCall", "assemblyLocalDefinition", 
    "assemblyAssignment", "assemblyIdentifierList", "assemblyStackAssignment", 
    "labelDefinition", "assemblySwitch", "assemblyCase", "assemblyFunctionDefinition", 
    "assemblyFunctionReturns", "assemblyFor", "assemblyIf", "assemblyLiteral", 
    "assemblyTypedVariableList", "assemblyType", "subAssembly", "numberLiteral", 
    "identifier", "hexLiteral", "stringLiteral",
  }
  staticData.predictionContextCache = antlr.NewPredictionContextCache()
  staticData.serializedATN = []int32{
	4, 1, 128, 1057, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 
	7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 
	7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 
	15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 
	2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 
	26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 
	7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 
	36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 
	2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 
	47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 
	7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 
	57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 
	2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 
	68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 
	7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 
	78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 
	2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 1, 0, 1, 0, 1, 
	0, 1, 0, 1, 0, 5, 0, 182, 8, 0, 10, 0, 12, 0, 185, 9, 0, 1, 0, 1, 0, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3, 3, 3, 198, 8, 3, 1, 
	4, 1, 4, 3, 4, 202, 8, 4, 1, 5, 3, 5, 205, 8, 5, 1, 5, 1, 5, 1, 6, 1, 6, 
	1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 215, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 
	221, 8, 7, 1, 7, 1, 7, 3, 7, 225, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 
	7, 1, 7, 1, 7, 5, 7, 235, 8, 7, 10, 7, 12, 7, 238, 9, 7, 1, 7, 1, 7, 1, 
	7, 1, 7, 1, 7, 3, 7, 245, 8, 7, 1, 8, 1, 8, 1, 8, 3, 8, 250, 8, 8, 1, 9, 
	3, 9, 253, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 5, 9, 261, 8, 9, 10, 
	9, 12, 9, 264, 9, 9, 3, 9, 266, 8, 9, 1, 9, 1, 9, 5, 9, 270, 8, 9, 10, 
	9, 12, 9, 273, 9, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 3, 10, 280, 8, 10, 
	1, 10, 3, 10, 283, 8, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 
	11, 3, 11, 292, 8, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 
	5, 12, 301, 8, 12, 10, 12, 12, 12, 304, 9, 12, 1, 12, 1, 12, 1, 12, 3, 
	12, 309, 8, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13, 
	318, 8, 13, 10, 13, 12, 13, 321, 9, 13, 1, 13, 1, 13, 3, 13, 325, 8, 13, 
	1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 332, 8, 14, 1, 14, 1, 14, 1, 
	15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 344, 8, 15, 
	10, 15, 12, 15, 347, 9, 15, 3, 15, 349, 8, 15, 1, 15, 1, 15, 1, 16, 1, 
	16, 1, 16, 3, 16, 356, 8, 16, 1, 16, 1, 16, 5, 16, 360, 8, 16, 10, 16, 
	12, 16, 363, 9, 16, 1, 16, 1, 16, 3, 16, 367, 8, 16, 1, 17, 1, 17, 1, 17, 
	1, 17, 3, 17, 373, 8, 17, 1, 17, 1, 17, 3, 17, 377, 8, 17, 1, 18, 1, 18, 
	1, 18, 1, 18, 3, 18, 383, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 388, 8, 18, 
	1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 
	20, 5, 20, 401, 8, 20, 10, 20, 12, 20, 404, 9, 20, 1, 21, 1, 21, 1, 21, 
	3, 21, 409, 8, 21, 1, 21, 3, 21, 412, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 
	3, 22, 418, 8, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 426, 
	8, 23, 1, 23, 1, 23, 5, 23, 430, 8, 23, 10, 23, 12, 23, 433, 9, 23, 1, 
	23, 1, 23, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 5, 25, 443, 8, 25, 
	10, 25, 12, 25, 446, 9, 25, 3, 25, 448, 8, 25, 1, 25, 1, 25, 1, 26, 1, 
	26, 3, 26, 454, 8, 26, 1, 26, 3, 26, 457, 8, 26, 1, 27, 1, 27, 1, 27, 1, 
	27, 5, 27, 463, 8, 27, 10, 27, 12, 27, 466, 9, 27, 3, 27, 468, 8, 27, 1, 
	27, 1, 27, 1, 28, 1, 28, 3, 28, 474, 8, 28, 1, 28, 3, 28, 477, 8, 28, 1, 
	29, 1, 29, 3, 29, 481, 8, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 
	1, 30, 3, 30, 490, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30, 495, 8, 30, 1, 30, 
	5, 30, 498, 8, 30, 10, 30, 12, 30, 501, 9, 30, 1, 31, 1, 31, 1, 31, 5, 
	31, 506, 8, 31, 10, 31, 12, 31, 509, 9, 31, 1, 32, 1, 32, 1, 32, 1, 32, 
	3, 32, 515, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1, 
	33, 3, 33, 525, 8, 33, 1, 34, 1, 34, 1, 35, 1, 35, 1, 36, 1, 36, 5, 36, 
	533, 8, 36, 10, 36, 12, 36, 536, 9, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 
	37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 
	3, 37, 553, 8, 37, 1, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 
	39, 1, 39, 1, 39, 3, 39, 565, 8, 39, 1, 40, 1, 40, 1, 40, 3, 40, 570, 8, 
	40, 1, 40, 1, 40, 4, 40, 574, 8, 40, 11, 40, 12, 40, 575, 1, 41, 1, 41, 
	3, 41, 580, 8, 41, 1, 41, 3, 41, 583, 8, 41, 1, 41, 1, 41, 1, 42, 1, 42, 
	1, 42, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 597, 8, 
	43, 1, 43, 1, 43, 3, 43, 601, 8, 43, 1, 43, 3, 43, 604, 8, 43, 1, 43, 1, 
	43, 1, 43, 1, 44, 1, 44, 3, 44, 611, 8, 44, 1, 45, 1, 45, 3, 45, 615, 8, 
	45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 
	1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 3, 49, 635, 8, 
	49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 
	1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 653, 8, 52, 1, 52, 1, 
	52, 3, 52, 657, 8, 52, 1, 52, 1, 52, 1, 53, 3, 53, 662, 8, 53, 1, 53, 1, 
	53, 3, 53, 666, 8, 53, 5, 53, 668, 8, 53, 10, 53, 12, 53, 671, 9, 53, 1, 
	54, 1, 54, 3, 54, 675, 8, 54, 1, 54, 5, 54, 678, 8, 54, 10, 54, 12, 54, 
	681, 9, 54, 1, 54, 3, 54, 684, 8, 54, 1, 54, 1, 54, 1, 55, 1, 55, 3, 55, 
	690, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 
	55, 3, 55, 701, 8, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 
	1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 
	56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 726, 8, 56, 1, 56, 1, 56, 
	1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 
	56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 
	1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 
	56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 
	1, 56, 1, 56, 1, 56, 3, 56, 775, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 
	56, 781, 8, 56, 1, 56, 1, 56, 3, 56, 785, 8, 56, 1, 56, 1, 56, 1, 56, 1, 
	56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 
	5, 56, 801, 8, 56, 10, 56, 12, 56, 804, 9, 56, 1, 57, 1, 57, 1, 57, 1, 
	57, 1, 57, 1, 57, 1, 57, 3, 57, 813, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 
	1, 57, 3, 57, 820, 8, 57, 3, 57, 822, 8, 57, 1, 58, 1, 58, 1, 58, 5, 58, 
	827, 8, 58, 10, 58, 12, 58, 830, 9, 58, 1, 59, 1, 59, 1, 59, 5, 59, 835, 
	8, 59, 10, 59, 12, 59, 838, 9, 59, 1, 59, 3, 59, 841, 8, 59, 1, 60, 1, 
	60, 1, 60, 1, 60, 1, 61, 1, 61, 3, 61, 849, 8, 61, 1, 61, 1, 61, 3, 61, 
	853, 8, 61, 3, 61, 855, 8, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 63, 
	1, 63, 3, 63, 864, 8, 63, 1, 63, 1, 63, 3, 63, 868, 8, 63, 5, 63, 870, 
	8, 63, 10, 63, 12, 63, 873, 9, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 5, 
	63, 880, 8, 63, 10, 63, 12, 63, 883, 9, 63, 3, 63, 885, 8, 63, 1, 63, 3, 
	63, 888, 8, 63, 1, 64, 1, 64, 3, 64, 892, 8, 64, 1, 65, 1, 65, 1, 65, 1, 
	65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 
	1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 912, 8, 65, 1, 66, 1, 66, 5, 66, 916, 
	8, 66, 10, 66, 12, 66, 919, 9, 66, 1, 66, 1, 66, 1, 67, 1, 67, 3, 67, 925, 
	8, 67, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 931, 8, 68, 1, 68, 1, 68, 3, 
	68, 935, 8, 68, 1, 68, 1, 68, 5, 68, 939, 8, 68, 10, 68, 12, 68, 942, 9, 
	68, 1, 68, 3, 68, 945, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 951, 8, 
	69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 5, 71, 960, 8, 71, 
	10, 71, 12, 71, 963, 9, 71, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1, 
	74, 1, 74, 1, 74, 5, 74, 974, 8, 74, 10, 74, 12, 74, 977, 9, 74, 1, 75, 
	1, 75, 1, 75, 3, 75, 982, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 988, 
	8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 994, 8, 76, 1, 76, 1, 76, 3, 
	76, 998, 8, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 78, 1, 78, 
	1, 78, 1, 78, 1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 
	80, 1, 80, 1, 80, 3, 80, 1021, 8, 80, 1, 80, 3, 80, 1024, 8, 80, 1, 81, 
	1, 81, 3, 81, 1028, 8, 81, 1, 81, 1, 81, 3, 81, 1032, 8, 81, 1, 82, 1, 
	82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 3, 84, 1043, 8, 84, 
	1, 85, 1, 85, 1, 86, 4, 86, 1048, 8, 86, 11, 86, 12, 86, 1049, 1, 87, 4, 
	87, 1053, 8, 87, 11, 87, 12, 87, 1054, 1, 87, 0, 2, 60, 112, 88, 0, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 
	42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 
	78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 
	112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 
	142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 
	172, 174, 0, 14, 1, 0, 3, 9, 1, 0, 18, 20, 1, 0, 38, 40, 4, 0, 106, 106, 
	113, 113, 117, 117, 119, 119, 1, 0, 56, 57, 1, 0, 60, 61, 1, 0, 62, 63, 
	2, 0, 12, 12, 66, 67, 1, 0, 68, 69, 1, 0, 5, 8, 1, 0, 72, 73, 2, 0, 9, 
	9, 77, 86, 1, 0, 99, 100, 4, 0, 13, 13, 40, 40, 52, 52, 123, 123, 1186, 
	0, 183, 1, 0, 0, 0, 2, 188, 1, 0, 0, 0, 4, 193, 1, 0, 0, 0, 6, 197, 1, 
	0, 0, 0, 8, 199, 1, 0, 0, 0, 10, 204, 1, 0, 0, 0, 12, 208, 1, 0, 0, 0, 
	14, 244, 1, 0, 0, 0, 16, 246, 1, 0, 0, 0, 18, 252, 1, 0, 0, 0, 20, 276, 
	1, 0, 0, 0, 22, 291, 1, 0, 0, 0, 24, 293, 1, 0, 0, 0, 26, 312, 1, 0, 0, 
	0, 28, 326, 1, 0, 0, 0, 30, 335, 1, 0, 0, 0, 32, 352, 1, 0, 0, 0, 34, 368, 
	1, 0, 0, 0, 36, 387, 1, 0, 0, 0, 38, 389, 1, 0, 0, 0, 40, 402, 1, 0, 0, 
	0, 42, 405, 1, 0, 0, 0, 44, 413, 1, 0, 0, 0, 46, 421, 1, 0, 0, 0, 48, 436, 
	1, 0, 0, 0, 50, 438, 1, 0, 0, 0, 52, 451, 1, 0, 0, 0, 54, 458, 1, 0, 0, 
	0, 56, 471, 1, 0, 0, 0, 58, 478, 1, 0, 0, 0, 60, 489, 1, 0, 0, 0, 62, 502, 
	1, 0, 0, 0, 64, 510, 1, 0, 0, 0, 66, 520, 1, 0, 0, 0, 68, 526, 1, 0, 0, 
	0, 70, 528, 1, 0, 0, 0, 72, 530, 1, 0, 0, 0, 74, 552, 1, 0, 0, 0, 76, 554, 
	1, 0, 0, 0, 78, 557, 1, 0, 0, 0, 80, 566, 1, 0, 0, 0, 82, 577, 1, 0, 0, 
	0, 84, 586, 1, 0, 0, 0, 86, 592, 1, 0, 0, 0, 88, 610, 1, 0, 0, 0, 90, 612, 
	1, 0, 0, 0, 92, 618, 1, 0, 0, 0, 94, 626, 1, 0, 0, 0, 96, 629, 1, 0, 0, 
	0, 98, 632, 1, 0, 0, 0, 100, 638, 1, 0, 0, 0, 102, 641, 1, 0, 0, 0, 104, 
	652, 1, 0, 0, 0, 106, 661, 1, 0, 0, 0, 108, 672, 1, 0, 0, 0, 110, 700, 
	1, 0, 0, 0, 112, 725, 1, 0, 0, 0, 114, 821, 1, 0, 0, 0, 116, 823, 1, 0, 
	0, 0, 118, 831, 1, 0, 0, 0, 120, 842, 1, 0, 0, 0, 122, 854, 1, 0, 0, 0, 
	124, 856, 1, 0, 0, 0, 126, 887, 1, 0, 0, 0, 128, 891, 1, 0, 0, 0, 130, 
	911, 1, 0, 0, 0, 132, 913, 1, 0, 0, 0, 134, 924, 1, 0, 0, 0, 136, 930, 
	1, 0, 0, 0, 138, 946, 1, 0, 0, 0, 140, 952, 1, 0, 0, 0, 142, 956, 1, 0, 
	0, 0, 144, 964, 1, 0, 0, 0, 146, 967, 1, 0, 0, 0, 148, 970, 1, 0, 0, 0, 
	150, 987, 1, 0, 0, 0, 152, 989, 1, 0, 0, 0, 154, 1001, 1, 0, 0, 0, 156, 
	1005, 1, 0, 0, 0, 158, 1011, 1, 0, 0, 0, 160, 1020, 1, 0, 0, 0, 162, 1025, 
	1, 0, 0, 0, 164, 1033, 1, 0, 0, 0, 166, 1036, 1, 0, 0, 0, 168, 1040, 1, 
	0, 0, 0, 170, 1044, 1, 0, 0, 0, 172, 1047, 1, 0, 0, 0, 174, 1052, 1, 0, 
	0, 0, 176, 182, 3, 2, 1, 0, 177, 182, 3, 14, 7, 0, 178, 182, 3, 30, 15, 
	0, 179, 182, 3, 46, 23, 0, 180, 182, 3, 18, 9, 0, 181, 176, 1, 0, 0, 0, 
	181, 177, 1, 0, 0, 0, 181, 178, 1, 0, 0, 0, 181, 179, 1, 0, 0, 0, 181, 
	180, 1, 0, 0, 0, 182, 185, 1, 0, 0, 0, 183, 181, 1, 0, 0, 0, 183, 184, 
	1, 0, 0, 0, 184, 186, 1, 0, 0, 0, 185, 183, 1, 0, 0, 0, 186, 187, 5, 0, 
	0, 1, 187, 1, 1, 0, 0, 0, 188, 189, 5, 1, 0, 0, 189, 190, 3, 4, 2, 0, 190, 
	191, 3, 6, 3, 0, 191, 192, 5, 2, 0, 0, 192, 3, 1, 0, 0, 0, 193, 194, 3, 
	170, 85, 0, 194, 5, 1, 0, 0, 0, 195, 198, 3, 8, 4, 0, 196, 198, 3, 112, 
	56, 0, 197, 195, 1, 0, 0, 0, 197, 196, 1, 0, 0, 0, 198, 7, 1, 0, 0, 0, 
	199, 201, 3, 10, 5, 0, 200, 202, 3, 10, 5, 0, 201, 200, 1, 0, 0, 0, 201, 
	202, 1, 0, 0, 0, 202, 9, 1, 0, 0, 0, 203, 205, 3, 12, 6, 0, 204, 203, 1, 
	0, 0, 0, 204, 205, 1, 0, 0, 0, 205, 206, 1, 0, 0, 0, 206, 207, 5, 125, 
	0, 0, 207, 11, 1, 0, 0, 0, 208, 209, 7, 0, 0, 0, 209, 13, 1, 0, 0, 0, 210, 
	211, 5, 10, 0, 0, 211, 214, 5, 124, 0, 0, 212, 213, 5, 11, 0, 0, 213, 215, 
	3, 170, 85, 0, 214, 212, 1, 0, 0, 0, 214, 215, 1, 0, 0, 0, 215, 216, 1, 
	0, 0, 0, 216, 245, 5, 2, 0, 0, 217, 220, 5, 10, 0, 0, 218, 221, 5, 12, 
	0, 0, 219, 221, 3, 170, 85, 0, 220, 218, 1, 0, 0, 0, 220, 219, 1, 0, 0, 
	0, 221, 224, 1, 0, 0, 0, 222, 223, 5, 11, 0, 0, 223, 225, 3, 170, 85, 0, 
	224, 222, 1, 0, 0, 0, 224, 225, 1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 
	227, 5, 13, 0, 0, 227, 228, 5, 124, 0, 0, 228, 245, 5, 2, 0, 0, 229, 230, 
	5, 10, 0, 0, 230, 231, 5, 14, 0, 0, 231, 236, 3, 16, 8, 0, 232, 233, 5, 
	15, 0, 0, 233, 235, 3, 16, 8, 0, 234, 232, 1, 0, 0, 0, 235, 238, 1, 0, 
	0, 0, 236, 234, 1, 0, 0, 0, 236, 237, 1, 0, 0, 0, 237, 239, 1, 0, 0, 0, 
	238, 236, 1, 0, 0, 0, 239, 240, 5, 16, 0, 0, 240, 241, 5, 13, 0, 0, 241, 
	242, 5, 124, 0, 0, 242, 243, 5, 2, 0, 0, 243, 245, 1, 0, 0, 0, 244, 210, 
	1, 0, 0, 0, 244, 217, 1, 0, 0, 0, 244, 229, 1, 0, 0, 0, 245, 15, 1, 0, 
	0, 0, 246, 249, 3, 170, 85, 0, 247, 248, 5, 11, 0, 0, 248, 250, 3, 170, 
	85, 0, 249, 247, 1, 0, 0, 0, 249, 250, 1, 0, 0, 0, 250, 17, 1, 0, 0, 0, 
	251, 253, 5, 17, 0, 0, 252, 251, 1, 0, 0, 0, 252, 253, 1, 0, 0, 0, 253, 
	254, 1, 0, 0, 0, 254, 255, 7, 1, 0, 0, 255, 265, 3, 170, 85, 0, 256, 257, 
	5, 21, 0, 0, 257, 262, 3, 20, 10, 0, 258, 259, 5, 15, 0, 0, 259, 261, 3, 
	20, 10, 0, 260, 258, 1, 0, 0, 0, 261, 264, 1, 0, 0, 0, 262, 260, 1, 0, 
	0, 0, 262, 263, 1, 0, 0, 0, 263, 266, 1, 0, 0, 0, 264, 262, 1, 0, 0, 0, 
	265, 256, 1, 0, 0, 0, 265, 266, 1, 0, 0, 0, 266, 267, 1, 0, 0, 0, 267, 
	271, 5, 14, 0, 0, 268, 270, 3, 22, 11, 0, 269, 268, 1, 0, 0, 0, 270, 273, 
	1, 0, 0, 0, 271, 269, 1, 0, 0, 0, 271, 272, 1, 0, 0, 0, 272, 274, 1, 0, 
	0, 0, 273, 271, 1, 0, 0, 0, 274, 275, 5, 16, 0, 0, 275, 19, 1, 0, 0, 0, 
	276, 282, 3, 62, 31, 0, 277, 279, 5, 22, 0, 0, 278, 280, 3, 116, 58, 0, 
	279, 278, 1, 0, 0, 0, 279, 280, 1, 0, 0, 0, 280, 281, 1, 0, 0, 0, 281, 
	283, 5, 23, 0, 0, 282, 277, 1, 0, 0, 0, 282, 283, 1, 0, 0, 0, 283, 21, 
	1, 0, 0, 0, 284, 292, 3, 24, 12, 0, 285, 292, 3, 28, 14, 0, 286, 292, 3, 
	30, 15, 0, 287, 292, 3, 32, 16, 0, 288, 292, 3, 34, 17, 0, 289, 292, 3, 
	44, 22, 0, 290, 292, 3, 46, 23, 0, 291, 284, 1, 0, 0, 0, 291, 285, 1, 0, 
	0, 0, 291, 286, 1, 0, 0, 0, 291, 287, 1, 0, 0, 0, 291, 288, 1, 0, 0, 0, 
	291, 289, 1, 0, 0, 0, 291, 290, 1, 0, 0, 0, 292, 23, 1, 0, 0, 0, 293, 302, 
	3, 60, 30, 0, 294, 301, 5, 115, 0, 0, 295, 301, 5, 112, 0, 0, 296, 301, 
	5, 114, 0, 0, 297, 301, 5, 106, 0, 0, 298, 301, 5, 107, 0, 0, 299, 301, 
	3, 26, 13, 0, 300, 294, 1, 0, 0, 0, 300, 295, 1, 0, 0, 0, 300, 296, 1, 
	0, 0, 0, 300, 297, 1, 0, 0, 0, 300, 298, 1, 0, 0, 0, 300, 299, 1, 0, 0, 
	0, 301, 304, 1, 0, 0, 0, 302, 300, 1, 0, 0, 0, 302, 303, 1, 0, 0, 0, 303, 
	305, 1, 0, 0, 0, 304, 302, 1, 0, 0, 0, 305, 308, 3, 170, 85, 0, 306, 307, 
	5, 9, 0, 0, 307, 309, 3, 112, 56, 0, 308, 306, 1, 0, 0, 0, 308, 309, 1, 
	0, 0, 0, 309, 310, 1, 0, 0, 0, 310, 311, 5, 2, 0, 0, 311, 25, 1, 0, 0, 
	0, 312, 324, 5, 24, 0, 0, 313, 314, 5, 22, 0, 0, 314, 319, 3, 62, 31, 0, 
	315, 316, 5, 15, 0, 0, 316, 318, 3, 62, 31, 0, 317, 315, 1, 0, 0, 0, 318, 
	321, 1, 0, 0, 0, 319, 317, 1, 0, 0, 0, 319, 320, 1, 0, 0, 0, 320, 322, 
	1, 0, 0, 0, 321, 319, 1, 0, 0, 0, 322, 323, 5, 23, 0, 0, 323, 325, 1, 0, 
	0, 0, 324, 313, 1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325, 27, 1, 0, 0, 0, 
	326, 327, 5, 25, 0, 0, 327, 328, 3, 170, 85, 0, 328, 331, 5, 26, 0, 0, 
	329, 332, 5, 12, 0, 0, 330, 332, 3, 60, 30, 0, 331, 329, 1, 0, 0, 0, 331, 
	330, 1, 0, 0, 0, 332, 333, 1, 0, 0, 0, 333, 334, 5, 2, 0, 0, 334, 29, 1, 
	0, 0, 0, 335, 336, 5, 27, 0, 0, 336, 337, 3, 170, 85, 0, 337, 348, 5, 14, 
	0, 0, 338, 339, 3, 58, 29, 0, 339, 345, 5, 2, 0, 0, 340, 341, 3, 58, 29, 
	0, 341, 342, 5, 2, 0, 0, 342, 344, 1, 0, 0, 0, 343, 340, 1, 0, 0, 0, 344, 
	347, 1, 0, 0, 0, 345, 343, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346, 349, 
	1, 0, 0, 0, 347, 345, 1, 0, 0, 0, 348, 338, 1, 0, 0, 0, 348, 349, 1, 0, 
	0, 0, 349, 350, 1, 0, 0, 0, 350, 351, 5, 16, 0, 0, 351, 31, 1, 0, 0, 0, 
	352, 353, 5, 28, 0, 0, 353, 355, 3, 170, 85, 0, 354, 356, 3, 50, 25, 0, 
	355, 354, 1, 0, 0, 0, 355, 356, 1, 0, 0, 0, 356, 361, 1, 0, 0, 0, 357, 
	360, 5, 116, 0, 0, 358, 360, 3, 26, 13, 0, 359, 357, 1, 0, 0, 0, 359, 358, 
	1, 0, 0, 0, 360, 363, 1, 0, 0, 0, 361, 359, 1, 0, 0, 0, 361, 362, 1, 0, 
	0, 0, 362, 366, 1, 0, 0, 0, 363, 361, 1, 0, 0, 0, 364, 367, 5, 2, 0, 0, 
	365, 367, 3, 72, 36, 0, 366, 364, 1, 0, 0, 0, 366, 365, 1, 0, 0, 0, 367, 
	33, 1, 0, 0, 0, 368, 369, 3, 36, 18, 0, 369, 370, 3, 50, 25, 0, 370, 372, 
	3, 40, 20, 0, 371, 373, 3, 38, 19, 0, 372, 371, 1, 0, 0, 0, 372, 373, 1, 
	0, 0, 0, 373, 376, 1, 0, 0, 0, 374, 377, 5, 2, 0, 0, 375, 377, 3, 72, 36, 
	0, 376, 374, 1, 0, 0, 0, 376, 375, 1, 0, 0, 0, 377, 35, 1, 0, 0, 0, 378, 
	382, 5, 29, 0, 0, 379, 383, 3, 170, 85, 0, 380, 383, 5, 122, 0, 0, 381, 
	383, 5, 121, 0, 0, 382, 379, 1, 0, 0, 0, 382, 380, 1, 0, 0, 0, 382, 381, 
	1, 0, 0, 0, 382, 383, 1, 0, 0, 0, 383, 388, 1, 0, 0, 0, 384, 388, 5, 120, 
	0, 0, 385, 388, 5, 121, 0, 0, 386, 388, 5, 122, 0, 0, 387, 378, 1, 0, 0, 
	0, 387, 384, 1, 0, 0, 0, 387, 385, 1, 0, 0, 0, 387, 386, 1, 0, 0, 0, 388, 
	37, 1, 0, 0, 0, 389, 390, 5, 30, 0, 0, 390, 391, 3, 50, 25, 0, 391, 39, 
	1, 0, 0, 0, 392, 401, 3, 42, 21, 0, 393, 401, 3, 70, 35, 0, 394, 401, 5, 
	110, 0, 0, 395, 401, 5, 115, 0, 0, 396, 401, 5, 112, 0, 0, 397, 401, 5, 
	114, 0, 0, 398, 401, 5, 116, 0, 0, 399, 401, 3, 26, 13, 0, 400, 392, 1, 
	0, 0, 0, 400, 393, 1, 0, 0, 0, 400, 394, 1, 0, 0, 0, 400, 395, 1, 0, 0, 
	0, 400, 396, 1, 0, 0, 0, 400, 397, 1, 0, 0, 0, 400, 398, 1, 0, 0, 0, 400, 
	399, 1, 0, 0, 0, 401, 404, 1, 0, 0, 0, 402, 400, 1, 0, 0, 0, 402, 403, 
	1, 0, 0, 0, 403, 41, 1, 0, 0, 0, 404, 402, 1, 0, 0, 0, 405, 411, 3, 170, 
	85, 0, 406, 408, 5, 22, 0, 0, 407, 409, 3, 116, 58, 0, 408, 407, 1, 0, 
	0, 0, 408, 409, 1, 0, 0, 0, 409, 410, 1, 0, 0, 0, 410, 412, 5, 23, 0, 0, 
	411, 406, 1, 0, 0, 0, 411, 412, 1, 0, 0, 0, 412, 43, 1, 0, 0, 0, 413, 414, 
	5, 31, 0, 0, 414, 415, 3, 170, 85, 0, 415, 417, 3, 54, 27, 0, 416, 418, 
	5, 104, 0, 0, 417, 416, 1, 0, 0, 0, 417, 418, 1, 0, 0, 0, 418, 419, 1, 
	0, 0, 0, 419, 420, 5, 2, 0, 0, 420, 45, 1, 0, 0, 0, 421, 422, 5, 32, 0, 
	0, 422, 423, 3, 170, 85, 0, 423, 425, 5, 14, 0, 0, 424, 426, 3, 48, 24, 
	0, 425, 424, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 431, 1, 0, 0, 0, 427, 
	428, 5, 15, 0, 0, 428, 430, 3, 48, 24, 0, 429, 427, 1, 0, 0, 0, 430, 433, 
	1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 431, 432, 1, 0, 0, 0, 432, 434, 1, 0, 
	0, 0, 433, 431, 1, 0, 0, 0, 434, 435, 5, 16, 0, 0, 435, 47, 1, 0, 0, 0, 
	436, 437, 3, 170, 85, 0, 437, 49, 1, 0, 0, 0, 438, 447, 5, 22, 0, 0, 439, 
	444, 3, 52, 26, 0, 440, 441, 5, 15, 0, 0, 441, 443, 3, 52, 26, 0, 442, 
	440, 1, 0, 0, 0, 443, 446, 1, 0, 0, 0, 444, 442, 1, 0, 0, 0, 444, 445, 
	1, 0, 0, 0, 445, 448, 1, 0, 0, 0, 446, 444, 1, 0, 0, 0, 447, 439, 1, 0, 
	0, 0, 447, 448, 1, 0, 0, 0, 448, 449, 1, 0, 0, 0, 449, 450, 5, 23, 0, 0, 
	450, 51, 1, 0, 0, 0, 451, 453, 3, 60, 30, 0, 452, 454, 3, 68, 34, 0, 453, 
	452, 1, 0, 0, 0, 453, 454, 1, 0, 0, 0, 454, 456, 1, 0, 0, 0, 455, 457, 
	3, 170, 85, 0, 456, 455, 1, 0, 0, 0, 456, 457, 1, 0, 0, 0, 457, 53, 1, 
	0, 0, 0, 458, 467, 5, 22, 0, 0, 459, 464, 3, 56, 28, 0, 460, 461, 5, 15, 
	0, 0, 461, 463, 3, 56, 28, 0, 462, 460, 1, 0, 0, 0, 463, 466, 1, 0, 0, 
	0, 464, 462, 1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 468, 1, 0, 0, 0, 466, 
	464, 1, 0, 0, 0, 467, 459, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 469, 
	1, 0, 0, 0, 469, 470, 5, 23, 0, 0, 470, 55, 1, 0, 0, 0, 471, 473, 3, 60, 
	30, 0, 472, 474, 5, 111, 0, 0, 473, 472, 1, 0, 0, 0, 473, 474, 1, 0, 0, 
	0, 474, 476, 1, 0, 0, 0, 475, 477, 3, 170, 85, 0, 476, 475, 1, 0, 0, 0, 
	476, 477, 1, 0, 0, 0, 477, 57, 1, 0, 0, 0, 478, 480, 3, 60, 30, 0, 479, 
	481, 3, 68, 34, 0, 480, 479, 1, 0, 0, 0, 480, 481, 1, 0, 0, 0, 481, 482, 
	1, 0, 0, 0, 482, 483, 3, 170, 85, 0, 483, 59, 1, 0, 0, 0, 484, 485, 6, 
	30, -1, 0, 485, 490, 3, 110, 55, 0, 486, 490, 3, 62, 31, 0, 487, 490, 3, 
	64, 32, 0, 488, 490, 3, 66, 33, 0, 489, 484, 1, 0, 0, 0, 489, 486, 1, 0, 
	0, 0, 489, 487, 1, 0, 0, 0, 489, 488, 1, 0, 0, 0, 490, 499, 1, 0, 0, 0, 
	491, 492, 10, 2, 0, 0, 492, 494, 5, 33, 0, 0, 493, 495, 3, 112, 56, 0, 
	494, 493, 1, 0, 0, 0, 494, 495, 1, 0, 0, 0, 495, 496, 1, 0, 0, 0, 496, 
	498, 5, 34, 0, 0, 497, 491, 1, 0, 0, 0, 498, 501, 1, 0, 0, 0, 499, 497, 
	1, 0, 0, 0, 499, 500, 1, 0, 0, 0, 500, 61, 1, 0, 0, 0, 501, 499, 1, 0, 
	0, 0, 502, 507, 3, 170, 85, 0, 503, 504, 5, 35, 0, 0, 504, 506, 3, 170, 
	85, 0, 505, 503, 1, 0, 0, 0, 506, 509, 1, 0, 0, 0, 507, 505, 1, 0, 0, 0, 
	507, 508, 1, 0, 0, 0, 508, 63, 1, 0, 0, 0, 509, 507, 1, 0, 0, 0, 510, 511, 
	5, 36, 0, 0, 511, 514, 5, 22, 0, 0, 512, 515, 3, 110, 55, 0, 513, 515, 
	3, 62, 31, 0, 514, 512, 1, 0, 0, 0, 514, 513, 1, 0, 0, 0, 515, 516, 1, 
	0, 0, 0, 516, 517, 5, 37, 0, 0, 517, 518, 3, 60, 30, 0, 518, 519, 5, 23, 
	0, 0, 519, 65, 1, 0, 0, 0, 520, 521, 5, 29, 0, 0, 521, 522, 3, 50, 25, 
	0, 522, 524, 3, 40, 20, 0, 523, 525, 3, 38, 19, 0, 524, 523, 1, 0, 0, 0, 
	524, 525, 1, 0, 0, 0, 525, 67, 1, 0, 0, 0, 526, 527, 7, 2, 0, 0, 527, 69, 
	1, 0, 0, 0, 528, 529, 7, 3, 0, 0, 529, 71, 1, 0, 0, 0, 530, 534, 5, 14, 
	0, 0, 531, 533, 3, 74, 37, 0, 532, 531, 1, 0, 0, 0, 533, 536, 1, 0, 0, 
	0, 534, 532, 1, 0, 0, 0, 534, 535, 1, 0, 0, 0, 535, 537, 1, 0, 0, 0, 536, 
	534, 1, 0, 0, 0, 537, 538, 5, 16, 0, 0, 538, 73, 1, 0, 0, 0, 539, 553, 
	3, 78, 39, 0, 540, 553, 3, 80, 40, 0, 541, 553, 3, 84, 42, 0, 542, 553, 
	3, 86, 43, 0, 543, 553, 3, 72, 36, 0, 544, 553, 3, 90, 45, 0, 545, 553, 
	3, 92, 46, 0, 546, 553, 3, 94, 47, 0, 547, 553, 3, 96, 48, 0, 548, 553, 
	3, 98, 49, 0, 549, 553, 3, 100, 50, 0, 550, 553, 3, 102, 51, 0, 551, 553, 
	3, 88, 44, 0, 552, 539, 1, 0, 0, 0, 552, 540, 1, 0, 0, 0, 552, 541, 1, 
	0, 0, 0, 552, 542, 1, 0, 0, 0, 552, 543, 1, 0, 0, 0, 552, 544, 1, 0, 0, 
	0, 552, 545, 1, 0, 0, 0, 552, 546, 1, 0, 0, 0, 552, 547, 1, 0, 0, 0, 552, 
	548, 1, 0, 0, 0, 552, 549, 1, 0, 0, 0, 552, 550, 1, 0, 0, 0, 552, 551, 
	1, 0, 0, 0, 553, 75, 1, 0, 0, 0, 554, 555, 3, 112, 56, 0, 555, 556, 5, 
	2, 0, 0, 556, 77, 1, 0, 0, 0, 557, 558, 5, 41, 0, 0, 558, 559, 5, 22, 0, 
	0, 559, 560, 3, 112, 56, 0, 560, 561, 5, 23, 0, 0, 561, 564, 3, 74, 37, 
	0, 562, 563, 5, 42, 0, 0, 563, 565, 3, 74, 37, 0, 564, 562, 1, 0, 0, 0, 
	564, 565, 1, 0, 0, 0, 565, 79, 1, 0, 0, 0, 566, 567, 5, 43, 0, 0, 567, 
	569, 3, 112, 56, 0, 568, 570, 3, 38, 19, 0, 569, 568, 1, 0, 0, 0, 569, 
	570, 1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 573, 3, 72, 36, 0, 572, 574, 
	3, 82, 41, 0, 573, 572, 1, 0, 0, 0, 574, 575, 1, 0, 0, 0, 575, 573, 1, 
	0, 0, 0, 575, 576, 1, 0, 0, 0, 576, 81, 1, 0, 0, 0, 577, 582, 5, 44, 0, 
	0, 578, 580, 3, 170, 85, 0, 579, 578, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 
	580, 581, 1, 0, 0, 0, 581, 583, 3, 50, 25, 0, 582, 579, 1, 0, 0, 0, 582, 
	583, 1, 0, 0, 0, 583, 584, 1, 0, 0, 0, 584, 585, 3, 72, 36, 0, 585, 83, 
	1, 0, 0, 0, 586, 587, 5, 45, 0, 0, 587, 588, 5, 22, 0, 0, 588, 589, 3, 
	112, 56, 0, 589, 590, 5, 23, 0, 0, 590, 591, 3, 74, 37, 0, 591, 85, 1, 
	0, 0, 0, 592, 593, 5, 26, 0, 0, 593, 596, 5, 22, 0, 0, 594, 597, 3, 88, 
	44, 0, 595, 597, 5, 2, 0, 0, 596, 594, 1, 0, 0, 0, 596, 595, 1, 0, 0, 0, 
	597, 600, 1, 0, 0, 0, 598, 601, 3, 76, 38, 0, 599, 601, 5, 2, 0, 0, 600, 
	598, 1, 0, 0, 0, 600, 599, 1, 0, 0, 0, 601, 603, 1, 0, 0, 0, 602, 604, 
	3, 112, 56, 0, 603, 602, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 605, 1, 
	0, 0, 0, 605, 606, 5, 23, 0, 0, 606, 607, 3, 74, 37, 0, 607, 87, 1, 0, 
	0, 0, 608, 611, 3, 104, 52, 0, 609, 611, 3, 76, 38, 0, 610, 608, 1, 0, 
	0, 0, 610, 609, 1, 0, 0, 0, 611, 89, 1, 0, 0, 0, 612, 614, 5, 46, 0, 0, 
	613, 615, 5, 124, 0, 0, 614, 613, 1, 0, 0, 0, 614, 615, 1, 0, 0, 0, 615, 
	616, 1, 0, 0, 0, 616, 617, 3, 132, 66, 0, 617, 91, 1, 0, 0, 0, 618, 619, 
	5, 47, 0, 0, 619, 620, 3, 74, 37, 0, 620, 621, 5, 45, 0, 0, 621, 622, 5, 
	22, 0, 0, 622, 623, 3, 112, 56, 0, 623, 624, 5, 23, 0, 0, 624, 625, 5, 
	2, 0, 0, 625, 93, 1, 0, 0, 0, 626, 627, 5, 108, 0, 0, 627, 628, 5, 2, 0, 
	0, 628, 95, 1, 0, 0, 0, 629, 630, 5, 105, 0, 0, 630, 631, 5, 2, 0, 0, 631, 
	97, 1, 0, 0, 0, 632, 634, 5, 48, 0, 0, 633, 635, 3, 112, 56, 0, 634, 633, 
	1, 0, 0, 0, 634, 635, 1, 0, 0, 0, 635, 636, 1, 0, 0, 0, 636, 637, 5, 2, 
	0, 0, 637, 99, 1, 0, 0, 0, 638, 639, 5, 49, 0, 0, 639, 640, 5, 2, 0, 0, 
	640, 101, 1, 0, 0, 0, 641, 642, 5, 50, 0, 0, 642, 643, 3, 124, 62, 0, 643, 
	644, 5, 2, 0, 0, 644, 103, 1, 0, 0, 0, 645, 646, 5, 51, 0, 0, 646, 653, 
	3, 108, 54, 0, 647, 653, 3, 58, 29, 0, 648, 649, 5, 22, 0, 0, 649, 650, 
	3, 106, 53, 0, 650, 651, 5, 23, 0, 0, 651, 653, 1, 0, 0, 0, 652, 645, 1, 
	0, 0, 0, 652, 647, 1, 0, 0, 0, 652, 648, 1, 0, 0, 0, 653, 656, 1, 0, 0, 
	0, 654, 655, 5, 9, 0, 0, 655, 657, 3, 112, 56, 0, 656, 654, 1, 0, 0, 0, 
	656, 657, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 659, 5, 2, 0, 0, 659, 
	105, 1, 0, 0, 0, 660, 662, 3, 58, 29, 0, 661, 660, 1, 0, 0, 0, 661, 662, 
	1, 0, 0, 0, 662, 669, 1, 0, 0, 0, 663, 665, 5, 15, 0, 0, 664, 666, 3, 58, 
	29, 0, 665, 664, 1, 0, 0, 0, 665, 666, 1, 0, 0, 0, 666, 668, 1, 0, 0, 0, 
	667, 663, 1, 0, 0, 0, 668, 671, 1, 0, 0, 0, 669, 667, 1, 0, 0, 0, 669, 
	670, 1, 0, 0, 0, 670, 107, 1, 0, 0, 0, 671, 669, 1, 0, 0, 0, 672, 679, 
	5, 22, 0, 0, 673, 675, 3, 170, 85, 0, 674, 673, 1, 0, 0, 0, 674, 675, 1, 
	0, 0, 0, 675, 676, 1, 0, 0, 0, 676, 678, 5, 15, 0, 0, 677, 674, 1, 0, 0, 
	0, 678, 681, 1, 0, 0, 0, 679, 677, 1, 0, 0, 0, 679, 680, 1, 0, 0, 0, 680, 
	683, 1, 0, 0, 0, 681, 679, 1, 0, 0, 0, 682, 684, 3, 170, 85, 0, 683, 682, 
	1, 0, 0, 0, 683, 684, 1, 0, 0, 0, 684, 685, 1, 0, 0, 0, 685, 686, 5, 23, 
	0, 0, 686, 109, 1, 0, 0, 0, 687, 689, 5, 52, 0, 0, 688, 690, 5, 113, 0, 
	0, 689, 688, 1, 0, 0, 0, 689, 690, 1, 0, 0, 0, 690, 701, 1, 0, 0, 0, 691, 
	701, 5, 53, 0, 0, 692, 701, 5, 54, 0, 0, 693, 701, 5, 51, 0, 0, 694, 701, 
	5, 93, 0, 0, 695, 701, 5, 94, 0, 0, 696, 701, 5, 55, 0, 0, 697, 701, 5, 
	95, 0, 0, 698, 701, 5, 96, 0, 0, 699, 701, 5, 97, 0, 0, 700, 687, 1, 0, 
	0, 0, 700, 691, 1, 0, 0, 0, 700, 692, 1, 0, 0, 0, 700, 693, 1, 0, 0, 0, 
	700, 694, 1, 0, 0, 0, 700, 695, 1, 0, 0, 0, 700, 696, 1, 0, 0, 0, 700, 
	697, 1, 0, 0, 0, 700, 698, 1, 0, 0, 0, 700, 699, 1, 0, 0, 0, 701, 111, 
	1, 0, 0, 0, 702, 703, 6, 56, -1, 0, 703, 704, 5, 58, 0, 0, 704, 726, 3, 
	60, 30, 0, 705, 706, 5, 113, 0, 0, 706, 707, 5, 22, 0, 0, 707, 708, 3, 
	112, 56, 0, 708, 709, 5, 23, 0, 0, 709, 726, 1, 0, 0, 0, 710, 711, 5, 22, 
	0, 0, 711, 712, 3, 112, 56, 0, 712, 713, 5, 23, 0, 0, 713, 726, 1, 0, 0, 
	0, 714, 715, 7, 4, 0, 0, 715, 726, 3, 112, 56, 19, 716, 717, 7, 5, 0, 0, 
	717, 726, 3, 112, 56, 18, 718, 719, 7, 6, 0, 0, 719, 726, 3, 112, 56, 17, 
	720, 721, 5, 64, 0, 0, 721, 726, 3, 112, 56, 16, 722, 723, 5, 4, 0, 0, 
	723, 726, 3, 112, 56, 15, 724, 726, 3, 114, 57, 0, 725, 702, 1, 0, 0, 0, 
	725, 705, 1, 0, 0, 0, 725, 710, 1, 0, 0, 0, 725, 714, 1, 0, 0, 0, 725, 
	716, 1, 0, 0, 0, 725, 718, 1, 0, 0, 0, 725, 720, 1, 0, 0, 0, 725, 722, 
	1, 0, 0, 0, 725, 724, 1, 0, 0, 0, 726, 802, 1, 0, 0, 0, 727, 728, 10, 14, 
	0, 0, 728, 729, 5, 65, 0, 0, 729, 801, 3, 112, 56, 15, 730, 731, 10, 13, 
	0, 0, 731, 732, 7, 7, 0, 0, 732, 801, 3, 112, 56, 14, 733, 734, 10, 12, 
	0, 0, 734, 735, 7, 5, 0, 0, 735, 801, 3, 112, 56, 13, 736, 737, 10, 11, 
	0, 0, 737, 738, 7, 8, 0, 0, 738, 801, 3, 112, 56, 12, 739, 740, 10, 10, 
	0, 0, 740, 741, 5, 70, 0, 0, 741, 801, 3, 112, 56, 11, 742, 743, 10, 9, 
	0, 0, 743, 744, 5, 3, 0, 0, 744, 801, 3, 112, 56, 10, 745, 746, 10, 8, 
	0, 0, 746, 747, 5, 71, 0, 0, 747, 801, 3, 112, 56, 9, 748, 749, 10, 7, 
	0, 0, 749, 750, 7, 9, 0, 0, 750, 801, 3, 112, 56, 8, 751, 752, 10, 6, 0, 
	0, 752, 753, 7, 10, 0, 0, 753, 801, 3, 112, 56, 7, 754, 755, 10, 5, 0, 
	0, 755, 756, 5, 74, 0, 0, 756, 801, 3, 112, 56, 6, 757, 758, 10, 4, 0, 
	0, 758, 759, 5, 75, 0, 0, 759, 801, 3, 112, 56, 5, 760, 761, 10, 3, 0, 
	0, 761, 762, 5, 76, 0, 0, 762, 763, 3, 112, 56, 0, 763, 764, 5, 59, 0, 
	0, 764, 765, 3, 112, 56, 4, 765, 801, 1, 0, 0, 0, 766, 767, 10, 2, 0, 0, 
	767, 768, 7, 11, 0, 0, 768, 801, 3, 112, 56, 3, 769, 770, 10, 28, 0, 0, 
	770, 801, 7, 4, 0, 0, 771, 772, 10, 26, 0, 0, 772, 774, 5, 33, 0, 0, 773, 
	775, 3, 112, 56, 0, 774, 773, 1, 0, 0, 0, 774, 775, 1, 0, 0, 0, 775, 776, 
	1, 0, 0, 0, 776, 801, 5, 34, 0, 0, 777, 778, 10, 25, 0, 0, 778, 780, 5, 
	33, 0, 0, 779, 781, 3, 112, 56, 0, 780, 779, 1, 0, 0, 0, 780, 781, 1, 0, 
	0, 0, 781, 782, 1, 0, 0, 0, 782, 784, 5, 59, 0, 0, 783, 785, 3, 112, 56, 
	0, 784, 783, 1, 0, 0, 0, 784, 785, 1, 0, 0, 0, 785, 786, 1, 0, 0, 0, 786, 
	801, 5, 34, 0, 0, 787, 788, 10, 24, 0, 0, 788, 789, 5, 35, 0, 0, 789, 801, 
	3, 170, 85, 0, 790, 791, 10, 23, 0, 0, 791, 792, 5, 14, 0, 0, 792, 793, 
	3, 118, 59, 0, 793, 794, 5, 16, 0, 0, 794, 801, 1, 0, 0, 0, 795, 796, 10, 
	22, 0, 0, 796, 797, 5, 22, 0, 0, 797, 798, 3, 122, 61, 0, 798, 799, 5, 
	23, 0, 0, 799, 801, 1, 0, 0, 0, 800, 727, 1, 0, 0, 0, 800, 730, 1, 0, 0, 
	0, 800, 733, 1, 0, 0, 0, 800, 736, 1, 0, 0, 0, 800, 739, 1, 0, 0, 0, 800, 
	742, 1, 0, 0, 0, 800, 745, 1, 0, 0, 0, 800, 748, 1, 0, 0, 0, 800, 751, 
	1, 0, 0, 0, 800, 754, 1, 0, 0, 0, 800, 757, 1, 0, 0, 0, 800, 760, 1, 0, 
	0, 0, 800, 766, 1, 0, 0, 0, 800, 769, 1, 0, 0, 0, 800, 771, 1, 0, 0, 0, 
	800, 777, 1, 0, 0, 0, 800, 787, 1, 0, 0, 0, 800, 790, 1, 0, 0, 0, 800, 
	795, 1, 0, 0, 0, 801, 804, 1, 0, 0, 0, 802, 800, 1, 0, 0, 0, 802, 803, 
	1, 0, 0, 0, 803, 113, 1, 0, 0, 0, 804, 802, 1, 0, 0, 0, 805, 822, 5, 98, 
	0, 0, 806, 822, 3, 168, 84, 0, 807, 822, 3, 172, 86, 0, 808, 822, 3, 174, 
	87, 0, 809, 812, 3, 170, 85, 0, 810, 811, 5, 33, 0, 0, 811, 813, 5, 34, 
	0, 0, 812, 810, 1, 0, 0, 0, 812, 813, 1, 0, 0, 0, 813, 822, 1, 0, 0, 0, 
	814, 822, 5, 118, 0, 0, 815, 822, 3, 126, 63, 0, 816, 819, 3, 128, 64, 
	0, 817, 818, 5, 33, 0, 0, 818, 820, 5, 34, 0, 0, 819, 817, 1, 0, 0, 0, 
	819, 820, 1, 0, 0, 0, 820, 822, 1, 0, 0, 0, 821, 805, 1, 0, 0, 0, 821, 
	806, 1, 0, 0, 0, 821, 807, 1, 0, 0, 0, 821, 808, 1, 0, 0, 0, 821, 809, 
	1, 0, 0, 0, 821, 814, 1, 0, 0, 0, 821, 815, 1, 0, 0, 0, 821, 816, 1, 0, 
	0, 0, 822, 115, 1, 0, 0, 0, 823, 828, 3, 112, 56, 0, 824, 825, 5, 15, 0, 
	0, 825, 827, 3, 112, 56, 0, 826, 824, 1, 0, 0, 0, 827, 830, 1, 0, 0, 0, 
	828, 826, 1, 0, 0, 0, 828, 829, 1, 0, 0, 0, 829, 117, 1, 0, 0, 0, 830, 
	828, 1, 0, 0, 0, 831, 836, 3, 120, 60, 0, 832, 833, 5, 15, 0, 0, 833, 835, 
	3, 120, 60, 0, 834, 832, 1, 0, 0, 0, 835, 838, 1, 0, 0, 0, 836, 834, 1, 
	0, 0, 0, 836, 837, 1, 0, 0, 0, 837, 840, 1, 0, 0, 0, 838, 836, 1, 0, 0, 
	0, 839, 841, 5, 15, 0, 0, 840, 839, 1, 0, 0, 0, 840, 841, 1, 0, 0, 0, 841, 
	119, 1, 0, 0, 0, 842, 843, 3, 170, 85, 0, 843, 844, 5, 59, 0, 0, 844, 845, 
	3, 112, 56, 0, 845, 121, 1, 0, 0, 0, 846, 848, 5, 14, 0, 0, 847, 849, 3, 
	118, 59, 0, 848, 847, 1, 0, 0, 0, 848, 849, 1, 0, 0, 0, 849, 850, 1, 0, 
	0, 0, 850, 855, 5, 16, 0, 0, 851, 853, 3, 116, 58, 0, 852, 851, 1, 0, 0, 
	0, 852, 853, 1, 0, 0, 0, 853, 855, 1, 0, 0, 0, 854, 846, 1, 0, 0, 0, 854, 
	852, 1, 0, 0, 0, 855, 123, 1, 0, 0, 0, 856, 857, 3, 112, 56, 0, 857, 858, 
	5, 22, 0, 0, 858, 859, 3, 122, 61, 0, 859, 860, 5, 23, 0, 0, 860, 125, 
	1, 0, 0, 0, 861, 863, 5, 22, 0, 0, 862, 864, 3, 112, 56, 0, 863, 862, 1, 
	0, 0, 0, 863, 864, 1, 0, 0, 0, 864, 871, 1, 0, 0, 0, 865, 867, 5, 15, 0, 
	0, 866, 868, 3, 112, 56, 0, 867, 866, 1, 0, 0, 0, 867, 868, 1, 0, 0, 0, 
	868, 870, 1, 0, 0, 0, 869, 865, 1, 0, 0, 0, 870, 873, 1, 0, 0, 0, 871, 
	869, 1, 0, 0, 0, 871, 872, 1, 0, 0, 0, 872, 874, 1, 0, 0, 0, 873, 871, 
	1, 0, 0, 0, 874, 888, 5, 23, 0, 0, 875, 884, 5, 33, 0, 0, 876, 881, 3, 
	112, 56, 0, 877, 878, 5, 15, 0, 0, 878, 880, 3, 112, 56, 0, 879, 877, 1, 
	0, 0, 0, 880, 883, 1, 0, 0, 0, 881, 879, 1, 0, 0, 0, 881, 882, 1, 0, 0, 
	0, 882, 885, 1, 0, 0, 0, 883, 881, 1, 0, 0, 0, 884, 876, 1, 0, 0, 0, 884, 
	885, 1, 0, 0, 0, 885, 886, 1, 0, 0, 0, 886, 888, 5, 34, 0, 0, 887, 861, 
	1, 0, 0, 0, 887, 875, 1, 0, 0, 0, 888, 127, 1, 0, 0, 0, 889, 892, 3, 110, 
	55, 0, 890, 892, 3, 62, 31, 0, 891, 889, 1, 0, 0, 0, 891, 890, 1, 0, 0, 
	0, 892, 129, 1, 0, 0, 0, 893, 912, 3, 170, 85, 0, 894, 912, 3, 132, 66, 
	0, 895, 912, 3, 134, 67, 0, 896, 912, 3, 138, 69, 0, 897, 912, 3, 140, 
	70, 0, 898, 912, 3, 144, 72, 0, 899, 912, 3, 146, 73, 0, 900, 912, 3, 148, 
	74, 0, 901, 912, 3, 152, 76, 0, 902, 912, 3, 156, 78, 0, 903, 912, 3, 158, 
	79, 0, 904, 912, 5, 105, 0, 0, 905, 912, 5, 108, 0, 0, 906, 912, 5, 109, 
	0, 0, 907, 912, 3, 166, 83, 0, 908, 912, 3, 168, 84, 0, 909, 912, 3, 174, 
	87, 0, 910, 912, 3, 172, 86, 0, 911, 893, 1, 0, 0, 0, 911, 894, 1, 0, 0, 
	0, 911, 895, 1, 0, 0, 0, 911, 896, 1, 0, 0, 0, 911, 897, 1, 0, 0, 0, 911, 
	898, 1, 0, 0, 0, 911, 899, 1, 0, 0, 0, 911, 900, 1, 0, 0, 0, 911, 901, 
	1, 0, 0, 0, 911, 902, 1, 0, 0, 0, 911, 903, 1, 0, 0, 0, 911, 904, 1, 0, 
	0, 0, 911, 905, 1, 0, 0, 0, 911, 906, 1, 0, 0, 0, 911, 907, 1, 0, 0, 0, 
	911, 908, 1, 0, 0, 0, 911, 909, 1, 0, 0, 0, 911, 910, 1, 0, 0, 0, 912, 
	131, 1, 0, 0, 0, 913, 917, 5, 14, 0, 0, 914, 916, 3, 130, 65, 0, 915, 914, 
	1, 0, 0, 0, 916, 919, 1, 0, 0, 0, 917, 915, 1, 0, 0, 0, 917, 918, 1, 0, 
	0, 0, 918, 920, 1, 0, 0, 0, 919, 917, 1, 0, 0, 0, 920, 921, 5, 16, 0, 0, 
	921, 133, 1, 0, 0, 0, 922, 925, 3, 136, 68, 0, 923, 925, 3, 160, 80, 0, 
	924, 922, 1, 0, 0, 0, 924, 923, 1, 0, 0, 0, 925, 135, 1, 0, 0, 0, 926, 
	931, 5, 48, 0, 0, 927, 931, 5, 52, 0, 0, 928, 931, 5, 55, 0, 0, 929, 931, 
	3, 170, 85, 0, 930, 926, 1, 0, 0, 0, 930, 927, 1, 0, 0, 0, 930, 928, 1, 
	0, 0, 0, 930, 929, 1, 0, 0, 0, 931, 944, 1, 0, 0, 0, 932, 934, 5, 22, 0, 
	0, 933, 935, 3, 134, 67, 0, 934, 933, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0, 
	935, 940, 1, 0, 0, 0, 936, 937, 5, 15, 0, 0, 937, 939, 3, 134, 67, 0, 938, 
	936, 1, 0, 0, 0, 939, 942, 1, 0, 0, 0, 940, 938, 1, 0, 0, 0, 940, 941, 
	1, 0, 0, 0, 941, 943, 1, 0, 0, 0, 942, 940, 1, 0, 0, 0, 943, 945, 5, 23, 
	0, 0, 944, 932, 1, 0, 0, 0, 944, 945, 1, 0, 0, 0, 945, 137, 1, 0, 0, 0, 
	946, 947, 5, 87, 0, 0, 947, 950, 3, 142, 71, 0, 948, 949, 5, 88, 0, 0, 
	949, 951, 3, 134, 67, 0, 950, 948, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 
	139, 1, 0, 0, 0, 952, 953, 3, 142, 71, 0, 953, 954, 5, 88, 0, 0, 954, 955, 
	3, 134, 67, 0, 955, 141, 1, 0, 0, 0, 956, 961, 3, 170, 85, 0, 957, 958, 
	5, 15, 0, 0, 958, 960, 3, 170, 85, 0, 959, 957, 1, 0, 0, 0, 960, 963, 1, 
	0, 0, 0, 961, 959, 1, 0, 0, 0, 961, 962, 1, 0, 0, 0, 962, 143, 1, 0, 0, 
	0, 963, 961, 1, 0, 0, 0, 964, 965, 5, 89, 0, 0, 965, 966, 3, 170, 85, 0, 
	966, 145, 1, 0, 0, 0, 967, 968, 3, 170, 85, 0, 968, 969, 5, 59, 0, 0, 969, 
	147, 1, 0, 0, 0, 970, 971, 5, 90, 0, 0, 971, 975, 3, 134, 67, 0, 972, 974, 
	3, 150, 75, 0, 973, 972, 1, 0, 0, 0, 974, 977, 1, 0, 0, 0, 975, 973, 1, 
	0, 0, 0, 975, 976, 1, 0, 0, 0, 976, 149, 1, 0, 0, 0, 977, 975, 1, 0, 0, 
	0, 978, 979, 5, 91, 0, 0, 979, 981, 3, 160, 80, 0, 980, 982, 3, 164, 82, 
	0, 981, 980, 1, 0, 0, 0, 981, 982, 1, 0, 0, 0, 982, 983, 1, 0, 0, 0, 983, 
	984, 3, 132, 66, 0, 984, 988, 1, 0, 0, 0, 985, 986, 5, 92, 0, 0, 986, 988, 
	3, 132, 66, 0, 987, 978, 1, 0, 0, 0, 987, 985, 1, 0, 0, 0, 988, 151, 1, 
	0, 0, 0, 989, 990, 5, 29, 0, 0, 990, 991, 3, 170, 85, 0, 991, 993, 5, 22, 
	0, 0, 992, 994, 3, 162, 81, 0, 993, 992, 1, 0, 0, 0, 993, 994, 1, 0, 0, 
	0, 994, 995, 1, 0, 0, 0, 995, 997, 5, 23, 0, 0, 996, 998, 3, 154, 77, 0, 
	997, 996, 1, 0, 0, 0, 997, 998, 1, 0, 0, 0, 998, 999, 1, 0, 0, 0, 999, 
	1000, 3, 132, 66, 0, 1000, 153, 1, 0, 0, 0, 1001, 1002, 5, 61, 0, 0, 1002, 
	1003, 5, 6, 0, 0, 1003, 1004, 3, 162, 81, 0, 1004, 155, 1, 0, 0, 0, 1005, 
	1006, 5, 26, 0, 0, 1006, 1007, 3, 132, 66, 0, 1007, 1008, 3, 134, 67, 0, 
	1008, 1009, 3, 132, 66, 0, 1009, 1010, 3, 132, 66, 0, 1010, 157, 1, 0, 
	0, 0, 1011, 1012, 5, 41, 0, 0, 1012, 1013, 3, 134, 67, 0, 1013, 1014, 3, 
	132, 66, 0, 1014, 159, 1, 0, 0, 0, 1015, 1021, 3, 174, 87, 0, 1016, 1021, 
	5, 99, 0, 0, 1017, 1021, 5, 100, 0, 0, 1018, 1021, 3, 172, 86, 0, 1019, 
	1021, 5, 98, 0, 0, 1020, 1015, 1, 0, 0, 0, 1020, 1016, 1, 0, 0, 0, 1020, 
	1017, 1, 0, 0, 0, 1020, 1018, 1, 0, 0, 0, 1020, 1019, 1, 0, 0, 0, 1021, 
	1023, 1, 0, 0, 0, 1022, 1024, 3, 164, 82, 0, 1023, 1022, 1, 0, 0, 0, 1023, 
	1024, 1, 0, 0, 0, 1024, 161, 1, 0, 0, 0, 1025, 1027, 3, 170, 85, 0, 1026, 
	1028, 3, 164, 82, 0, 1027, 1026, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 
	1031, 1, 0, 0, 0, 1029, 1030, 5, 15, 0, 0, 1030, 1032, 3, 162, 81, 0, 1031, 
	1029, 1, 0, 0, 0, 1031, 1032, 1, 0, 0, 0, 1032, 163, 1, 0, 0, 0, 1033, 
	1034, 5, 59, 0, 0, 1034, 1035, 3, 170, 85, 0, 1035, 165, 1, 0, 0, 0, 1036, 
	1037, 5, 46, 0, 0, 1037, 1038, 3, 170, 85, 0, 1038, 1039, 3, 132, 66, 0, 
	1039, 167, 1, 0, 0, 0, 1040, 1042, 7, 12, 0, 0, 1041, 1043, 5, 101, 0, 
	0, 1042, 1041, 1, 0, 0, 0, 1042, 1043, 1, 0, 0, 0, 1043, 169, 1, 0, 0, 
	0, 1044, 1045, 7, 13, 0, 0, 1045, 171, 1, 0, 0, 0, 1046, 1048, 5, 102, 
	0, 0, 1047, 1046, 1, 0, 0, 0, 1048, 1049, 1, 0, 0, 0, 1049, 1047, 1, 0, 
	0, 0, 1049, 1050, 1, 0, 0, 0, 1050, 173, 1, 0, 0, 0, 1051, 1053, 5, 124, 
	0, 0, 1052, 1051, 1, 0, 0, 0, 1053, 1054, 1, 0, 0, 0, 1054, 1052, 1, 0, 
	0, 0, 1054, 1055, 1, 0, 0, 0, 1055, 175, 1, 0, 0, 0, 122, 181, 183, 197, 
	201, 204, 214, 220, 224, 236, 244, 249, 252, 262, 265, 271, 279, 282, 291, 
	300, 302, 308, 319, 324, 331, 345, 348, 355, 359, 361, 366, 372, 376, 382, 
	387, 400, 402, 408, 411, 417, 425, 431, 444, 447, 453, 456, 464, 467, 473, 
	476, 480, 489, 494, 499, 507, 514, 524, 534, 552, 564, 569, 575, 579, 582, 
	596, 600, 603, 610, 614, 634, 652, 656, 661, 665, 669, 674, 679, 683, 689, 
	700, 725, 774, 780, 784, 800, 802, 812, 819, 821, 828, 836, 840, 848, 852, 
	854, 863, 867, 871, 881, 884, 887, 891, 911, 917, 924, 930, 934, 940, 944, 
	950, 961, 975, 981, 987, 993, 997, 1020, 1023, 1027, 1031, 1042, 1049, 
	1054,
}
  deserializer := antlr.NewATNDeserializer(nil)
  staticData.atn = deserializer.Deserialize(staticData.serializedATN)
  atn := staticData.atn
  staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
  decisionToDFA := staticData.decisionToDFA
  for index, state := range atn.DecisionToState {
    decisionToDFA[index] = antlr.NewDFA(state, index)
  }
}

// SolidityParserInit initializes any static state used to implement SolidityParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSolidityParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SolidityParserInit() {
  staticData := &solidityParserStaticData
  staticData.once.Do(solidityParserInit)
}

// NewSolidityParser produces a new parser instance for the optional input antlr.TokenStream.
func NewSolidityParser(input antlr.TokenStream) *SolidityParser {
	SolidityParserInit()
	this := new(SolidityParser)
	this.BaseParser = antlr.NewBaseParser(input)
  staticData := &solidityParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "Solidity.g4"

	return this
}


// SolidityParser tokens.
const (
	SolidityParserEOF = antlr.TokenEOF
	SolidityParserT__0 = 1
	SolidityParserT__1 = 2
	SolidityParserT__2 = 3
	SolidityParserT__3 = 4
	SolidityParserT__4 = 5
	SolidityParserT__5 = 6
	SolidityParserT__6 = 7
	SolidityParserT__7 = 8
	SolidityParserT__8 = 9
	SolidityParserT__9 = 10
	SolidityParserT__10 = 11
	SolidityParserT__11 = 12
	SolidityParserT__12 = 13
	SolidityParserT__13 = 14
	SolidityParserT__14 = 15
	SolidityParserT__15 = 16
	SolidityParserT__16 = 17
	SolidityParserT__17 = 18
	SolidityParserT__18 = 19
	SolidityParserT__19 = 20
	SolidityParserT__20 = 21
	SolidityParserT__21 = 22
	SolidityParserT__22 = 23
	SolidityParserT__23 = 24
	SolidityParserT__24 = 25
	SolidityParserT__25 = 26
	SolidityParserT__26 = 27
	SolidityParserT__27 = 28
	SolidityParserT__28 = 29
	SolidityParserT__29 = 30
	SolidityParserT__30 = 31
	SolidityParserT__31 = 32
	SolidityParserT__32 = 33
	SolidityParserT__33 = 34
	SolidityParserT__34 = 35
	SolidityParserT__35 = 36
	SolidityParserT__36 = 37
	SolidityParserT__37 = 38
	SolidityParserT__38 = 39
	SolidityParserT__39 = 40
	SolidityParserT__40 = 41
	SolidityParserT__41 = 42
	SolidityParserT__42 = 43
	SolidityParserT__43 = 44
	SolidityParserT__44 = 45
	SolidityParserT__45 = 46
	SolidityParserT__46 = 47
	SolidityParserT__47 = 48
	SolidityParserT__48 = 49
	SolidityParserT__49 = 50
	SolidityParserT__50 = 51
	SolidityParserT__51 = 52
	SolidityParserT__52 = 53
	SolidityParserT__53 = 54
	SolidityParserT__54 = 55
	SolidityParserT__55 = 56
	SolidityParserT__56 = 57
	SolidityParserT__57 = 58
	SolidityParserT__58 = 59
	SolidityParserT__59 = 60
	SolidityParserT__60 = 61
	SolidityParserT__61 = 62
	SolidityParserT__62 = 63
	SolidityParserT__63 = 64
	SolidityParserT__64 = 65
	SolidityParserT__65 = 66
	SolidityParserT__66 = 67
	SolidityParserT__67 = 68
	SolidityParserT__68 = 69
	SolidityParserT__69 = 70
	SolidityParserT__70 = 71
	SolidityParserT__71 = 72
	SolidityParserT__72 = 73
	SolidityParserT__73 = 74
	SolidityParserT__74 = 75
	SolidityParserT__75 = 76
	SolidityParserT__76 = 77
	SolidityParserT__77 = 78
	SolidityParserT__78 = 79
	SolidityParserT__79 = 80
	SolidityParserT__80 = 81
	SolidityParserT__81 = 82
	SolidityParserT__82 = 83
	SolidityParserT__83 = 84
	SolidityParserT__84 = 85
	SolidityParserT__85 = 86
	SolidityParserT__86 = 87
	SolidityParserT__87 = 88
	SolidityParserT__88 = 89
	SolidityParserT__89 = 90
	SolidityParserT__90 = 91
	SolidityParserT__91 = 92
	SolidityParserInt = 93
	SolidityParserUint = 94
	SolidityParserByte = 95
	SolidityParserFixed = 96
	SolidityParserUfixed = 97
	SolidityParserBooleanLiteral = 98
	SolidityParserDecimalNumber = 99
	SolidityParserHexNumber = 100
	SolidityParserNumberUnit = 101
	SolidityParserHexLiteralFragment = 102
	SolidityParserReservedKeyword = 103
	SolidityParserAnonymousKeyword = 104
	SolidityParserBreakKeyword = 105
	SolidityParserConstantKeyword = 106
	SolidityParserImmutableKeyword = 107
	SolidityParserContinueKeyword = 108
	SolidityParserLeaveKeyword = 109
	SolidityParserExternalKeyword = 110
	SolidityParserIndexedKeyword = 111
	SolidityParserInternalKeyword = 112
	SolidityParserPayableKeyword = 113
	SolidityParserPrivateKeyword = 114
	SolidityParserPublicKeyword = 115
	SolidityParserVirtualKeyword = 116
	SolidityParserPureKeyword = 117
	SolidityParserTypeKeyword = 118
	SolidityParserViewKeyword = 119
	SolidityParserConstructorKeyword = 120
	SolidityParserFallbackKeyword = 121
	SolidityParserReceiveKeyword = 122
	SolidityParserIdentifier = 123
	SolidityParserStringLiteralFragment = 124
	SolidityParserVersionLiteral = 125
	SolidityParserWS = 126
	SolidityParserCOMMENT = 127
	SolidityParserLINE_COMMENT = 128
)

// SolidityParser rules.
const (
	SolidityParserRULE_sourceUnit = 0
	SolidityParserRULE_pragmaDirective = 1
	SolidityParserRULE_pragmaName = 2
	SolidityParserRULE_pragmaValue = 3
	SolidityParserRULE_version = 4
	SolidityParserRULE_versionConstraint = 5
	SolidityParserRULE_versionOperator = 6
	SolidityParserRULE_importDirective = 7
	SolidityParserRULE_importDeclaration = 8
	SolidityParserRULE_contractDefinition = 9
	SolidityParserRULE_inheritanceSpecifier = 10
	SolidityParserRULE_contractPart = 11
	SolidityParserRULE_stateVariableDeclaration = 12
	SolidityParserRULE_overrideSpecifier = 13
	SolidityParserRULE_usingForDeclaration = 14
	SolidityParserRULE_structDefinition = 15
	SolidityParserRULE_modifierDefinition = 16
	SolidityParserRULE_functionDefinition = 17
	SolidityParserRULE_functionDescriptor = 18
	SolidityParserRULE_returnParameters = 19
	SolidityParserRULE_modifierList = 20
	SolidityParserRULE_modifierInvocation = 21
	SolidityParserRULE_eventDefinition = 22
	SolidityParserRULE_enumDefinition = 23
	SolidityParserRULE_enumValue = 24
	SolidityParserRULE_parameterList = 25
	SolidityParserRULE_parameter = 26
	SolidityParserRULE_eventParameterList = 27
	SolidityParserRULE_eventParameter = 28
	SolidityParserRULE_variableDeclaration = 29
	SolidityParserRULE_typeName = 30
	SolidityParserRULE_userDefinedTypeName = 31
	SolidityParserRULE_mapping = 32
	SolidityParserRULE_functionTypeName = 33
	SolidityParserRULE_storageLocation = 34
	SolidityParserRULE_stateMutability = 35
	SolidityParserRULE_block = 36
	SolidityParserRULE_statement = 37
	SolidityParserRULE_expressionStatement = 38
	SolidityParserRULE_ifStatement = 39
	SolidityParserRULE_tryStatement = 40
	SolidityParserRULE_catchClause = 41
	SolidityParserRULE_whileStatement = 42
	SolidityParserRULE_forStatement = 43
	SolidityParserRULE_simpleStatement = 44
	SolidityParserRULE_inlineAssemblyStatement = 45
	SolidityParserRULE_doWhileStatement = 46
	SolidityParserRULE_continueStatement = 47
	SolidityParserRULE_breakStatement = 48
	SolidityParserRULE_returnStatement = 49
	SolidityParserRULE_throwStatement = 50
	SolidityParserRULE_emitStatement = 51
	SolidityParserRULE_variableDeclarationStatement = 52
	SolidityParserRULE_variableDeclarationList = 53
	SolidityParserRULE_identifierList = 54
	SolidityParserRULE_elementaryTypeName = 55
	SolidityParserRULE_expression = 56
	SolidityParserRULE_primaryExpression = 57
	SolidityParserRULE_expressionList = 58
	SolidityParserRULE_nameValueList = 59
	SolidityParserRULE_nameValue = 60
	SolidityParserRULE_functionCallArguments = 61
	SolidityParserRULE_functionCall = 62
	SolidityParserRULE_tupleExpression = 63
	SolidityParserRULE_typeNameExpression = 64
	SolidityParserRULE_assemblyItem = 65
	SolidityParserRULE_assemblyBlock = 66
	SolidityParserRULE_assemblyExpression = 67
	SolidityParserRULE_assemblyCall = 68
	SolidityParserRULE_assemblyLocalDefinition = 69
	SolidityParserRULE_assemblyAssignment = 70
	SolidityParserRULE_assemblyIdentifierList = 71
	SolidityParserRULE_assemblyStackAssignment = 72
	SolidityParserRULE_labelDefinition = 73
	SolidityParserRULE_assemblySwitch = 74
	SolidityParserRULE_assemblyCase = 75
	SolidityParserRULE_assemblyFunctionDefinition = 76
	SolidityParserRULE_assemblyFunctionReturns = 77
	SolidityParserRULE_assemblyFor = 78
	SolidityParserRULE_assemblyIf = 79
	SolidityParserRULE_assemblyLiteral = 80
	SolidityParserRULE_assemblyTypedVariableList = 81
	SolidityParserRULE_assemblyType = 82
	SolidityParserRULE_subAssembly = 83
	SolidityParserRULE_numberLiteral = 84
	SolidityParserRULE_identifier = 85
	SolidityParserRULE_hexLiteral = 86
	SolidityParserRULE_stringLiteral = 87
)

// ISourceUnitContext is an interface to support dynamic dispatch.
type ISourceUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceUnitContext differentiates from other interfaces.
	IsSourceUnitContext()
}

type SourceUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceUnitContext() *SourceUnitContext {
	var p = new(SourceUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_sourceUnit
	return p
}

func (*SourceUnitContext) IsSourceUnitContext() {}

func NewSourceUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceUnitContext {
	var p = new(SourceUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_sourceUnit

	return p
}

func (s *SourceUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(SolidityParserEOF, 0)
}

func (s *SourceUnitContext) AllPragmaDirective() []IPragmaDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPragmaDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IPragmaDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPragmaDirectiveContext); ok {
			tst[i] = t.(IPragmaDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) PragmaDirective(i int) IPragmaDirectiveContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragmaDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragmaDirectiveContext)
}

func (s *SourceUnitContext) AllImportDirective() []IImportDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IImportDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDirectiveContext); ok {
			tst[i] = t.(IImportDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) ImportDirective(i int) IImportDirectiveContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDirectiveContext)
}

func (s *SourceUnitContext) AllStructDefinition() []IStructDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IStructDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructDefinitionContext); ok {
			tst[i] = t.(IStructDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) StructDefinition(i int) IStructDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDefinitionContext)
}

func (s *SourceUnitContext) AllEnumDefinition() []IEnumDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IEnumDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumDefinitionContext); ok {
			tst[i] = t.(IEnumDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) EnumDefinition(i int) IEnumDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDefinitionContext)
}

func (s *SourceUnitContext) AllContractDefinition() []IContractDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContractDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IContractDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContractDefinitionContext); ok {
			tst[i] = t.(IContractDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SourceUnitContext) ContractDefinition(i int) IContractDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContractDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContractDefinitionContext)
}

func (s *SourceUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SourceUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterSourceUnit(s)
	}
}

func (s *SourceUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitSourceUnit(s)
	}
}




func (p *SolidityParser) SourceUnit() (localctx ISourceUnitContext) {
	this := p
	_ = this

	localctx = NewSourceUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SolidityParserRULE_sourceUnit)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(183)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ((((_la - 1)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 1))) & ((1 << (SolidityParserT__0 - 1)) | (1 << (SolidityParserT__9 - 1)) | (1 << (SolidityParserT__16 - 1)) | (1 << (SolidityParserT__17 - 1)) | (1 << (SolidityParserT__18 - 1)) | (1 << (SolidityParserT__19 - 1)) | (1 << (SolidityParserT__26 - 1)) | (1 << (SolidityParserT__31 - 1)))) != 0) {
		p.SetState(181)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SolidityParserT__0:
			{
				p.SetState(176)
				p.PragmaDirective()
			}


		case SolidityParserT__9:
			{
				p.SetState(177)
				p.ImportDirective()
			}


		case SolidityParserT__26:
			{
				p.SetState(178)
				p.StructDefinition()
			}


		case SolidityParserT__31:
			{
				p.SetState(179)
				p.EnumDefinition()
			}


		case SolidityParserT__16, SolidityParserT__17, SolidityParserT__18, SolidityParserT__19:
			{
				p.SetState(180)
				p.ContractDefinition()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(185)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(186)
		p.Match(SolidityParserEOF)
	}



	return localctx
}


// IPragmaDirectiveContext is an interface to support dynamic dispatch.
type IPragmaDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPragmaDirectiveContext differentiates from other interfaces.
	IsPragmaDirectiveContext()
}

type PragmaDirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragmaDirectiveContext() *PragmaDirectiveContext {
	var p = new(PragmaDirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaDirective
	return p
}

func (*PragmaDirectiveContext) IsPragmaDirectiveContext() {}

func NewPragmaDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PragmaDirectiveContext {
	var p = new(PragmaDirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_pragmaDirective

	return p
}

func (s *PragmaDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *PragmaDirectiveContext) PragmaName() IPragmaNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragmaNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragmaNameContext)
}

func (s *PragmaDirectiveContext) PragmaValue() IPragmaValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragmaValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragmaValueContext)
}

func (s *PragmaDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PragmaDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PragmaDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterPragmaDirective(s)
	}
}

func (s *PragmaDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitPragmaDirective(s)
	}
}




func (p *SolidityParser) PragmaDirective() (localctx IPragmaDirectiveContext) {
	this := p
	_ = this

	localctx = NewPragmaDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SolidityParserRULE_pragmaDirective)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(188)
		p.Match(SolidityParserT__0)
	}
	{
		p.SetState(189)
		p.PragmaName()
	}
	{
		p.SetState(190)
		p.PragmaValue()
	}
	{
		p.SetState(191)
		p.Match(SolidityParserT__1)
	}



	return localctx
}


// IPragmaNameContext is an interface to support dynamic dispatch.
type IPragmaNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPragmaNameContext differentiates from other interfaces.
	IsPragmaNameContext()
}

type PragmaNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragmaNameContext() *PragmaNameContext {
	var p = new(PragmaNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaName
	return p
}

func (*PragmaNameContext) IsPragmaNameContext() {}

func NewPragmaNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PragmaNameContext {
	var p = new(PragmaNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_pragmaName

	return p
}

func (s *PragmaNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PragmaNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PragmaNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PragmaNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PragmaNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterPragmaName(s)
	}
}

func (s *PragmaNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitPragmaName(s)
	}
}




func (p *SolidityParser) PragmaName() (localctx IPragmaNameContext) {
	this := p
	_ = this

	localctx = NewPragmaNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SolidityParserRULE_pragmaName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(193)
		p.Identifier()
	}



	return localctx
}


// IPragmaValueContext is an interface to support dynamic dispatch.
type IPragmaValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPragmaValueContext differentiates from other interfaces.
	IsPragmaValueContext()
}

type PragmaValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragmaValueContext() *PragmaValueContext {
	var p = new(PragmaValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_pragmaValue
	return p
}

func (*PragmaValueContext) IsPragmaValueContext() {}

func NewPragmaValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PragmaValueContext {
	var p = new(PragmaValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_pragmaValue

	return p
}

func (s *PragmaValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PragmaValueContext) Version() IVersionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionContext)
}

func (s *PragmaValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PragmaValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PragmaValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PragmaValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterPragmaValue(s)
	}
}

func (s *PragmaValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitPragmaValue(s)
	}
}




func (p *SolidityParser) PragmaValue() (localctx IPragmaValueContext) {
	this := p
	_ = this

	localctx = NewPragmaValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SolidityParserRULE_pragmaValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(197)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(195)
			p.Version()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(196)
			p.expression(0)
		}

	}


	return localctx
}


// IVersionContext is an interface to support dynamic dispatch.
type IVersionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVersionContext differentiates from other interfaces.
	IsVersionContext()
}

type VersionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionContext() *VersionContext {
	var p = new(VersionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_version
	return p
}

func (*VersionContext) IsVersionContext() {}

func NewVersionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionContext {
	var p = new(VersionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_version

	return p
}

func (s *VersionContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionContext) AllVersionConstraint() []IVersionConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVersionConstraintContext); ok {
			len++
		}
	}

	tst := make([]IVersionConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVersionConstraintContext); ok {
			tst[i] = t.(IVersionConstraintContext)
			i++
		}
	}

	return tst
}

func (s *VersionContext) VersionConstraint(i int) IVersionConstraintContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionConstraintContext)
}

func (s *VersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVersion(s)
	}
}

func (s *VersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVersion(s)
	}
}




func (p *SolidityParser) Version() (localctx IVersionContext) {
	this := p
	_ = this

	localctx = NewVersionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SolidityParserRULE_version)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(199)
		p.VersionConstraint()
	}
	p.SetState(201)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__2) | (1 << SolidityParserT__3) | (1 << SolidityParserT__4) | (1 << SolidityParserT__5) | (1 << SolidityParserT__6) | (1 << SolidityParserT__7) | (1 << SolidityParserT__8))) != 0) || _la == SolidityParserVersionLiteral {
		{
			p.SetState(200)
			p.VersionConstraint()
		}

	}



	return localctx
}


// IVersionConstraintContext is an interface to support dynamic dispatch.
type IVersionConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVersionConstraintContext differentiates from other interfaces.
	IsVersionConstraintContext()
}

type VersionConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionConstraintContext() *VersionConstraintContext {
	var p = new(VersionConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_versionConstraint
	return p
}

func (*VersionConstraintContext) IsVersionConstraintContext() {}

func NewVersionConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionConstraintContext {
	var p = new(VersionConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_versionConstraint

	return p
}

func (s *VersionConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionConstraintContext) VersionLiteral() antlr.TerminalNode {
	return s.GetToken(SolidityParserVersionLiteral, 0)
}

func (s *VersionConstraintContext) VersionOperator() IVersionOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionOperatorContext)
}

func (s *VersionConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VersionConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVersionConstraint(s)
	}
}

func (s *VersionConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVersionConstraint(s)
	}
}




func (p *SolidityParser) VersionConstraint() (localctx IVersionConstraintContext) {
	this := p
	_ = this

	localctx = NewVersionConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SolidityParserRULE_versionConstraint)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(204)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__2) | (1 << SolidityParserT__3) | (1 << SolidityParserT__4) | (1 << SolidityParserT__5) | (1 << SolidityParserT__6) | (1 << SolidityParserT__7) | (1 << SolidityParserT__8))) != 0) {
		{
			p.SetState(203)
			p.VersionOperator()
		}

	}
	{
		p.SetState(206)
		p.Match(SolidityParserVersionLiteral)
	}



	return localctx
}


// IVersionOperatorContext is an interface to support dynamic dispatch.
type IVersionOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVersionOperatorContext differentiates from other interfaces.
	IsVersionOperatorContext()
}

type VersionOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionOperatorContext() *VersionOperatorContext {
	var p = new(VersionOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_versionOperator
	return p
}

func (*VersionOperatorContext) IsVersionOperatorContext() {}

func NewVersionOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionOperatorContext {
	var p = new(VersionOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_versionOperator

	return p
}

func (s *VersionOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *VersionOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VersionOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVersionOperator(s)
	}
}

func (s *VersionOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVersionOperator(s)
	}
}




func (p *SolidityParser) VersionOperator() (localctx IVersionOperatorContext) {
	this := p
	_ = this

	localctx = NewVersionOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SolidityParserRULE_versionOperator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(208)
		_la = p.GetTokenStream().LA(1)

		if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__2) | (1 << SolidityParserT__3) | (1 << SolidityParserT__4) | (1 << SolidityParserT__5) | (1 << SolidityParserT__6) | (1 << SolidityParserT__7) | (1 << SolidityParserT__8))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IImportDirectiveContext is an interface to support dynamic dispatch.
type IImportDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportDirectiveContext differentiates from other interfaces.
	IsImportDirectiveContext()
}

type ImportDirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDirectiveContext() *ImportDirectiveContext {
	var p = new(ImportDirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_importDirective
	return p
}

func (*ImportDirectiveContext) IsImportDirectiveContext() {}

func NewImportDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDirectiveContext {
	var p = new(ImportDirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_importDirective

	return p
}

func (s *ImportDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDirectiveContext) StringLiteralFragment() antlr.TerminalNode {
	return s.GetToken(SolidityParserStringLiteralFragment, 0)
}

func (s *ImportDirectiveContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ImportDirectiveContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportDirectiveContext) AllImportDeclaration() []IImportDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IImportDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDeclarationContext); ok {
			tst[i] = t.(IImportDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImportDirectiveContext) ImportDeclaration(i int) IImportDeclarationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *ImportDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ImportDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterImportDirective(s)
	}
}

func (s *ImportDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitImportDirective(s)
	}
}




func (p *SolidityParser) ImportDirective() (localctx IImportDirectiveContext) {
	this := p
	_ = this

	localctx = NewImportDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SolidityParserRULE_importDirective)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(244)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(210)
			p.Match(SolidityParserT__9)
		}
		{
			p.SetState(211)
			p.Match(SolidityParserStringLiteralFragment)
		}
		p.SetState(214)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == SolidityParserT__10 {
			{
				p.SetState(212)
				p.Match(SolidityParserT__10)
			}
			{
				p.SetState(213)
				p.Identifier()
			}

		}
		{
			p.SetState(216)
			p.Match(SolidityParserT__1)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(217)
			p.Match(SolidityParserT__9)
		}
		p.SetState(220)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SolidityParserT__11:
			{
				p.SetState(218)
				p.Match(SolidityParserT__11)
			}


		case SolidityParserT__12, SolidityParserT__39, SolidityParserT__51, SolidityParserIdentifier:
			{
				p.SetState(219)
				p.Identifier()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(224)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == SolidityParserT__10 {
			{
				p.SetState(222)
				p.Match(SolidityParserT__10)
			}
			{
				p.SetState(223)
				p.Identifier()
			}

		}
		{
			p.SetState(226)
			p.Match(SolidityParserT__12)
		}
		{
			p.SetState(227)
			p.Match(SolidityParserStringLiteralFragment)
		}
		{
			p.SetState(228)
			p.Match(SolidityParserT__1)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(229)
			p.Match(SolidityParserT__9)
		}
		{
			p.SetState(230)
			p.Match(SolidityParserT__13)
		}
		{
			p.SetState(231)
			p.ImportDeclaration()
		}
		p.SetState(236)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == SolidityParserT__14 {
			{
				p.SetState(232)
				p.Match(SolidityParserT__14)
			}
			{
				p.SetState(233)
				p.ImportDeclaration()
			}


			p.SetState(238)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(239)
			p.Match(SolidityParserT__15)
		}
		{
			p.SetState(240)
			p.Match(SolidityParserT__12)
		}
		{
			p.SetState(241)
			p.Match(SolidityParserStringLiteralFragment)
		}
		{
			p.SetState(242)
			p.Match(SolidityParserT__1)
		}

	}


	return localctx
}


// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_importDeclaration
	return p
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ImportDeclarationContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterImportDeclaration(s)
	}
}

func (s *ImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitImportDeclaration(s)
	}
}




func (p *SolidityParser) ImportDeclaration() (localctx IImportDeclarationContext) {
	this := p
	_ = this

	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SolidityParserRULE_importDeclaration)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(246)
		p.Identifier()
	}
	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__10 {
		{
			p.SetState(247)
			p.Match(SolidityParserT__10)
		}
		{
			p.SetState(248)
			p.Identifier()
		}

	}



	return localctx
}


// IContractDefinitionContext is an interface to support dynamic dispatch.
type IContractDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContractDefinitionContext differentiates from other interfaces.
	IsContractDefinitionContext()
}

type ContractDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContractDefinitionContext() *ContractDefinitionContext {
	var p = new(ContractDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_contractDefinition
	return p
}

func (*ContractDefinitionContext) IsContractDefinitionContext() {}

func NewContractDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContractDefinitionContext {
	var p = new(ContractDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_contractDefinition

	return p
}

func (s *ContractDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ContractDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContractDefinitionContext) AllInheritanceSpecifier() []IInheritanceSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInheritanceSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IInheritanceSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInheritanceSpecifierContext); ok {
			tst[i] = t.(IInheritanceSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ContractDefinitionContext) InheritanceSpecifier(i int) IInheritanceSpecifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceSpecifierContext)
}

func (s *ContractDefinitionContext) AllContractPart() []IContractPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IContractPartContext); ok {
			len++
		}
	}

	tst := make([]IContractPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IContractPartContext); ok {
			tst[i] = t.(IContractPartContext)
			i++
		}
	}

	return tst
}

func (s *ContractDefinitionContext) ContractPart(i int) IContractPartContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContractPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContractPartContext)
}

func (s *ContractDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContractDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ContractDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterContractDefinition(s)
	}
}

func (s *ContractDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitContractDefinition(s)
	}
}




func (p *SolidityParser) ContractDefinition() (localctx IContractDefinitionContext) {
	this := p
	_ = this

	localctx = NewContractDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SolidityParserRULE_contractDefinition)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(252)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__16 {
		{
			p.SetState(251)
			p.Match(SolidityParserT__16)
		}

	}
	{
		p.SetState(254)
		_la = p.GetTokenStream().LA(1)

		if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__17) | (1 << SolidityParserT__18) | (1 << SolidityParserT__19))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(255)
		p.Identifier()
	}
	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__20 {
		{
			p.SetState(256)
			p.Match(SolidityParserT__20)
		}
		{
			p.SetState(257)
			p.InheritanceSpecifier()
		}
		p.SetState(262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == SolidityParserT__14 {
			{
				p.SetState(258)
				p.Match(SolidityParserT__14)
			}
			{
				p.SetState(259)
				p.InheritanceSpecifier()
			}


			p.SetState(264)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(267)
		p.Match(SolidityParserT__13)
	}
	p.SetState(271)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__12) | (1 << SolidityParserT__24) | (1 << SolidityParserT__26) | (1 << SolidityParserT__27) | (1 << SolidityParserT__28) | (1 << SolidityParserT__30))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (SolidityParserT__31 - 32)) | (1 << (SolidityParserT__35 - 32)) | (1 << (SolidityParserT__39 - 32)) | (1 << (SolidityParserT__50 - 32)) | (1 << (SolidityParserT__51 - 32)) | (1 << (SolidityParserT__52 - 32)) | (1 << (SolidityParserT__53 - 32)) | (1 << (SolidityParserT__54 - 32)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserConstructorKeyword - 93)) | (1 << (SolidityParserFallbackKeyword - 93)) | (1 << (SolidityParserReceiveKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)))) != 0) {
		{
			p.SetState(268)
			p.ContractPart()
		}


		p.SetState(273)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(274)
		p.Match(SolidityParserT__15)
	}



	return localctx
}


// IInheritanceSpecifierContext is an interface to support dynamic dispatch.
type IInheritanceSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInheritanceSpecifierContext differentiates from other interfaces.
	IsInheritanceSpecifierContext()
}

type InheritanceSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceSpecifierContext() *InheritanceSpecifierContext {
	var p = new(InheritanceSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifier
	return p
}

func (*InheritanceSpecifierContext) IsInheritanceSpecifierContext() {}

func NewInheritanceSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceSpecifierContext {
	var p = new(InheritanceSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_inheritanceSpecifier

	return p
}

func (s *InheritanceSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceSpecifierContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *InheritanceSpecifierContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *InheritanceSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InheritanceSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterInheritanceSpecifier(s)
	}
}

func (s *InheritanceSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitInheritanceSpecifier(s)
	}
}




func (p *SolidityParser) InheritanceSpecifier() (localctx IInheritanceSpecifierContext) {
	this := p
	_ = this

	localctx = NewInheritanceSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SolidityParserRULE_inheritanceSpecifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(276)
		p.UserDefinedTypeName()
	}
	p.SetState(282)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__21 {
		{
			p.SetState(277)
			p.Match(SolidityParserT__21)
		}
		p.SetState(279)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__21))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
			{
				p.SetState(278)
				p.ExpressionList()
			}

		}
		{
			p.SetState(281)
			p.Match(SolidityParserT__22)
		}

	}



	return localctx
}


// IContractPartContext is an interface to support dynamic dispatch.
type IContractPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContractPartContext differentiates from other interfaces.
	IsContractPartContext()
}

type ContractPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContractPartContext() *ContractPartContext {
	var p = new(ContractPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_contractPart
	return p
}

func (*ContractPartContext) IsContractPartContext() {}

func NewContractPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContractPartContext {
	var p = new(ContractPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_contractPart

	return p
}

func (s *ContractPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ContractPartContext) StateVariableDeclaration() IStateVariableDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStateVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStateVariableDeclarationContext)
}

func (s *ContractPartContext) UsingForDeclaration() IUsingForDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingForDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingForDeclarationContext)
}

func (s *ContractPartContext) StructDefinition() IStructDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDefinitionContext)
}

func (s *ContractPartContext) ModifierDefinition() IModifierDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierDefinitionContext)
}

func (s *ContractPartContext) FunctionDefinition() IFunctionDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *ContractPartContext) EventDefinition() IEventDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventDefinitionContext)
}

func (s *ContractPartContext) EnumDefinition() IEnumDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDefinitionContext)
}

func (s *ContractPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContractPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ContractPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterContractPart(s)
	}
}

func (s *ContractPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitContractPart(s)
	}
}




func (p *SolidityParser) ContractPart() (localctx IContractPartContext) {
	this := p
	_ = this

	localctx = NewContractPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SolidityParserRULE_contractPart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(284)
			p.StateVariableDeclaration()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(285)
			p.UsingForDeclaration()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(286)
			p.StructDefinition()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(287)
			p.ModifierDefinition()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(288)
			p.FunctionDefinition()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(289)
			p.EventDefinition()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(290)
			p.EnumDefinition()
		}

	}


	return localctx
}


// IStateVariableDeclarationContext is an interface to support dynamic dispatch.
type IStateVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStateVariableDeclarationContext differentiates from other interfaces.
	IsStateVariableDeclarationContext()
}

type StateVariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStateVariableDeclarationContext() *StateVariableDeclarationContext {
	var p = new(StateVariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_stateVariableDeclaration
	return p
}

func (*StateVariableDeclarationContext) IsStateVariableDeclarationContext() {}

func NewStateVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StateVariableDeclarationContext {
	var p = new(StateVariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_stateVariableDeclaration

	return p
}

func (s *StateVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StateVariableDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *StateVariableDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StateVariableDeclarationContext) AllPublicKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPublicKeyword)
}

func (s *StateVariableDeclarationContext) PublicKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPublicKeyword, i)
}

func (s *StateVariableDeclarationContext) AllInternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserInternalKeyword)
}

func (s *StateVariableDeclarationContext) InternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserInternalKeyword, i)
}

func (s *StateVariableDeclarationContext) AllPrivateKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPrivateKeyword)
}

func (s *StateVariableDeclarationContext) PrivateKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPrivateKeyword, i)
}

func (s *StateVariableDeclarationContext) AllConstantKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserConstantKeyword)
}

func (s *StateVariableDeclarationContext) ConstantKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserConstantKeyword, i)
}

func (s *StateVariableDeclarationContext) AllImmutableKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserImmutableKeyword)
}

func (s *StateVariableDeclarationContext) ImmutableKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserImmutableKeyword, i)
}

func (s *StateVariableDeclarationContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *StateVariableDeclarationContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *StateVariableDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StateVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StateVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StateVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStateVariableDeclaration(s)
	}
}

func (s *StateVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStateVariableDeclaration(s)
	}
}




func (p *SolidityParser) StateVariableDeclaration() (localctx IStateVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewStateVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SolidityParserRULE_stateVariableDeclaration)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(293)
		p.typeName(0)
	}
	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == SolidityParserT__23 || ((((_la - 106)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 106))) & ((1 << (SolidityParserConstantKeyword - 106)) | (1 << (SolidityParserImmutableKeyword - 106)) | (1 << (SolidityParserInternalKeyword - 106)) | (1 << (SolidityParserPrivateKeyword - 106)) | (1 << (SolidityParserPublicKeyword - 106)))) != 0) {
		p.SetState(300)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SolidityParserPublicKeyword:
			{
				p.SetState(294)
				p.Match(SolidityParserPublicKeyword)
			}


		case SolidityParserInternalKeyword:
			{
				p.SetState(295)
				p.Match(SolidityParserInternalKeyword)
			}


		case SolidityParserPrivateKeyword:
			{
				p.SetState(296)
				p.Match(SolidityParserPrivateKeyword)
			}


		case SolidityParserConstantKeyword:
			{
				p.SetState(297)
				p.Match(SolidityParserConstantKeyword)
			}


		case SolidityParserImmutableKeyword:
			{
				p.SetState(298)
				p.Match(SolidityParserImmutableKeyword)
			}


		case SolidityParserT__23:
			{
				p.SetState(299)
				p.OverrideSpecifier()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(304)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(305)
		p.Identifier()
	}
	p.SetState(308)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__8 {
		{
			p.SetState(306)
			p.Match(SolidityParserT__8)
		}
		{
			p.SetState(307)
			p.expression(0)
		}

	}
	{
		p.SetState(310)
		p.Match(SolidityParserT__1)
	}



	return localctx
}


// IOverrideSpecifierContext is an interface to support dynamic dispatch.
type IOverrideSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOverrideSpecifierContext differentiates from other interfaces.
	IsOverrideSpecifierContext()
}

type OverrideSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverrideSpecifierContext() *OverrideSpecifierContext {
	var p = new(OverrideSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_overrideSpecifier
	return p
}

func (*OverrideSpecifierContext) IsOverrideSpecifierContext() {}

func NewOverrideSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverrideSpecifierContext {
	var p = new(OverrideSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_overrideSpecifier

	return p
}

func (s *OverrideSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *OverrideSpecifierContext) AllUserDefinedTypeName() []IUserDefinedTypeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			len++
		}
	}

	tst := make([]IUserDefinedTypeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserDefinedTypeNameContext); ok {
			tst[i] = t.(IUserDefinedTypeNameContext)
			i++
		}
	}

	return tst
}

func (s *OverrideSpecifierContext) UserDefinedTypeName(i int) IUserDefinedTypeNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *OverrideSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverrideSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OverrideSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterOverrideSpecifier(s)
	}
}

func (s *OverrideSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitOverrideSpecifier(s)
	}
}




func (p *SolidityParser) OverrideSpecifier() (localctx IOverrideSpecifierContext) {
	this := p
	_ = this

	localctx = NewOverrideSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SolidityParserRULE_overrideSpecifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(312)
		p.Match(SolidityParserT__23)
	}
	p.SetState(324)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(313)
			p.Match(SolidityParserT__21)
		}
		{
			p.SetState(314)
			p.UserDefinedTypeName()
		}
		p.SetState(319)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == SolidityParserT__14 {
			{
				p.SetState(315)
				p.Match(SolidityParserT__14)
			}
			{
				p.SetState(316)
				p.UserDefinedTypeName()
			}


			p.SetState(321)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(322)
			p.Match(SolidityParserT__22)
		}


	}



	return localctx
}


// IUsingForDeclarationContext is an interface to support dynamic dispatch.
type IUsingForDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUsingForDeclarationContext differentiates from other interfaces.
	IsUsingForDeclarationContext()
}

type UsingForDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingForDeclarationContext() *UsingForDeclarationContext {
	var p = new(UsingForDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_usingForDeclaration
	return p
}

func (*UsingForDeclarationContext) IsUsingForDeclarationContext() {}

func NewUsingForDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingForDeclarationContext {
	var p = new(UsingForDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_usingForDeclaration

	return p
}

func (s *UsingForDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingForDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UsingForDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *UsingForDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingForDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UsingForDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterUsingForDeclaration(s)
	}
}

func (s *UsingForDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitUsingForDeclaration(s)
	}
}




func (p *SolidityParser) UsingForDeclaration() (localctx IUsingForDeclarationContext) {
	this := p
	_ = this

	localctx = NewUsingForDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SolidityParserRULE_usingForDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(326)
		p.Match(SolidityParserT__24)
	}
	{
		p.SetState(327)
		p.Identifier()
	}
	{
		p.SetState(328)
		p.Match(SolidityParserT__25)
	}
	p.SetState(331)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__11:
		{
			p.SetState(329)
			p.Match(SolidityParserT__11)
		}


	case SolidityParserT__12, SolidityParserT__28, SolidityParserT__35, SolidityParserT__39, SolidityParserT__50, SolidityParserT__51, SolidityParserT__52, SolidityParserT__53, SolidityParserT__54, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserIdentifier:
		{
			p.SetState(330)
			p.typeName(0)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(333)
		p.Match(SolidityParserT__1)
	}



	return localctx
}


// IStructDefinitionContext is an interface to support dynamic dispatch.
type IStructDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructDefinitionContext differentiates from other interfaces.
	IsStructDefinitionContext()
}

type StructDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDefinitionContext() *StructDefinitionContext {
	var p = new(StructDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_structDefinition
	return p
}

func (*StructDefinitionContext) IsStructDefinitionContext() {}

func NewStructDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDefinitionContext {
	var p = new(StructDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_structDefinition

	return p
}

func (s *StructDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StructDefinitionContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *StructDefinitionContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *StructDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StructDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStructDefinition(s)
	}
}

func (s *StructDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStructDefinition(s)
	}
}




func (p *SolidityParser) StructDefinition() (localctx IStructDefinitionContext) {
	this := p
	_ = this

	localctx = NewStructDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SolidityParserRULE_structDefinition)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(335)
		p.Match(SolidityParserT__26)
	}
	{
		p.SetState(336)
		p.Identifier()
	}
	{
		p.SetState(337)
		p.Match(SolidityParserT__13)
	}
	p.SetState(348)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__12 || _la == SolidityParserT__28 || ((((_la - 36)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 36))) & ((1 << (SolidityParserT__35 - 36)) | (1 << (SolidityParserT__39 - 36)) | (1 << (SolidityParserT__50 - 36)) | (1 << (SolidityParserT__51 - 36)) | (1 << (SolidityParserT__52 - 36)) | (1 << (SolidityParserT__53 - 36)) | (1 << (SolidityParserT__54 - 36)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserIdentifier - 93)))) != 0) {
		{
			p.SetState(338)
			p.VariableDeclaration()
		}
		{
			p.SetState(339)
			p.Match(SolidityParserT__1)
		}
		p.SetState(345)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == SolidityParserT__12 || _la == SolidityParserT__28 || ((((_la - 36)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 36))) & ((1 << (SolidityParserT__35 - 36)) | (1 << (SolidityParserT__39 - 36)) | (1 << (SolidityParserT__50 - 36)) | (1 << (SolidityParserT__51 - 36)) | (1 << (SolidityParserT__52 - 36)) | (1 << (SolidityParserT__53 - 36)) | (1 << (SolidityParserT__54 - 36)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserIdentifier - 93)))) != 0) {
			{
				p.SetState(340)
				p.VariableDeclaration()
			}
			{
				p.SetState(341)
				p.Match(SolidityParserT__1)
			}


			p.SetState(347)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(350)
		p.Match(SolidityParserT__15)
	}



	return localctx
}


// IModifierDefinitionContext is an interface to support dynamic dispatch.
type IModifierDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierDefinitionContext differentiates from other interfaces.
	IsModifierDefinitionContext()
}

type ModifierDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierDefinitionContext() *ModifierDefinitionContext {
	var p = new(ModifierDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierDefinition
	return p
}

func (*ModifierDefinitionContext) IsModifierDefinitionContext() {}

func NewModifierDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierDefinitionContext {
	var p = new(ModifierDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_modifierDefinition

	return p
}

func (s *ModifierDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifierDefinitionContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ModifierDefinitionContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ModifierDefinitionContext) AllVirtualKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserVirtualKeyword)
}

func (s *ModifierDefinitionContext) VirtualKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserVirtualKeyword, i)
}

func (s *ModifierDefinitionContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifierDefinitionContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *ModifierDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ModifierDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterModifierDefinition(s)
	}
}

func (s *ModifierDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitModifierDefinition(s)
	}
}




func (p *SolidityParser) ModifierDefinition() (localctx IModifierDefinitionContext) {
	this := p
	_ = this

	localctx = NewModifierDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SolidityParserRULE_modifierDefinition)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(352)
		p.Match(SolidityParserT__27)
	}
	{
		p.SetState(353)
		p.Identifier()
	}
	p.SetState(355)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__21 {
		{
			p.SetState(354)
			p.ParameterList()
		}

	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == SolidityParserT__23 || _la == SolidityParserVirtualKeyword {
		p.SetState(359)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SolidityParserVirtualKeyword:
			{
				p.SetState(357)
				p.Match(SolidityParserVirtualKeyword)
			}


		case SolidityParserT__23:
			{
				p.SetState(358)
				p.OverrideSpecifier()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(363)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__1:
		{
			p.SetState(364)
			p.Match(SolidityParserT__1)
		}


	case SolidityParserT__13:
		{
			p.SetState(365)
			p.Block()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IFunctionDefinitionContext is an interface to support dynamic dispatch.
type IFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDefinitionContext differentiates from other interfaces.
	IsFunctionDefinitionContext()
}

type FunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDefinitionContext() *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_functionDefinition
	return p
}

func (*FunctionDefinitionContext) IsFunctionDefinitionContext() {}

func NewFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionDefinition

	return p
}

func (s *FunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDefinitionContext) FunctionDescriptor() IFunctionDescriptorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDescriptorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDescriptorContext)
}

func (s *FunctionDefinitionContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionDefinitionContext) ModifierList() IModifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *FunctionDefinitionContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionDefinitionContext) ReturnParameters() IReturnParametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnParametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnParametersContext)
}

func (s *FunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionDefinition(s)
	}
}

func (s *FunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionDefinition(s)
	}
}




func (p *SolidityParser) FunctionDefinition() (localctx IFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SolidityParserRULE_functionDefinition)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		p.FunctionDescriptor()
	}
	{
		p.SetState(369)
		p.ParameterList()
	}
	{
		p.SetState(370)
		p.ModifierList()
	}
	p.SetState(372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__29 {
		{
			p.SetState(371)
			p.ReturnParameters()
		}

	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__1:
		{
			p.SetState(374)
			p.Match(SolidityParserT__1)
		}


	case SolidityParserT__13:
		{
			p.SetState(375)
			p.Block()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IFunctionDescriptorContext is an interface to support dynamic dispatch.
type IFunctionDescriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDescriptorContext differentiates from other interfaces.
	IsFunctionDescriptorContext()
}

type FunctionDescriptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDescriptorContext() *FunctionDescriptorContext {
	var p = new(FunctionDescriptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_functionDescriptor
	return p
}

func (*FunctionDescriptorContext) IsFunctionDescriptorContext() {}

func NewFunctionDescriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDescriptorContext {
	var p = new(FunctionDescriptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionDescriptor

	return p
}

func (s *FunctionDescriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDescriptorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDescriptorContext) ReceiveKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserReceiveKeyword, 0)
}

func (s *FunctionDescriptorContext) FallbackKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserFallbackKeyword, 0)
}

func (s *FunctionDescriptorContext) ConstructorKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserConstructorKeyword, 0)
}

func (s *FunctionDescriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDescriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionDescriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionDescriptor(s)
	}
}

func (s *FunctionDescriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionDescriptor(s)
	}
}




func (p *SolidityParser) FunctionDescriptor() (localctx IFunctionDescriptorContext) {
	this := p
	_ = this

	localctx = NewFunctionDescriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SolidityParserRULE_functionDescriptor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(387)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__28:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(378)
			p.Match(SolidityParserT__28)
		}
		p.SetState(382)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SolidityParserT__12, SolidityParserT__39, SolidityParserT__51, SolidityParserIdentifier:
			{
				p.SetState(379)
				p.Identifier()
			}


		case SolidityParserReceiveKeyword:
			{
				p.SetState(380)
				p.Match(SolidityParserReceiveKeyword)
			}


		case SolidityParserFallbackKeyword:
			{
				p.SetState(381)
				p.Match(SolidityParserFallbackKeyword)
			}


		case SolidityParserT__21:



		default:
		}


	case SolidityParserConstructorKeyword:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(384)
			p.Match(SolidityParserConstructorKeyword)
		}


	case SolidityParserFallbackKeyword:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(385)
			p.Match(SolidityParserFallbackKeyword)
		}


	case SolidityParserReceiveKeyword:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(386)
			p.Match(SolidityParserReceiveKeyword)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IReturnParametersContext is an interface to support dynamic dispatch.
type IReturnParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnParametersContext differentiates from other interfaces.
	IsReturnParametersContext()
}

type ReturnParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnParametersContext() *ReturnParametersContext {
	var p = new(ReturnParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_returnParameters
	return p
}

func (*ReturnParametersContext) IsReturnParametersContext() {}

func NewReturnParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnParametersContext {
	var p = new(ReturnParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_returnParameters

	return p
}

func (s *ReturnParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnParametersContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ReturnParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReturnParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterReturnParameters(s)
	}
}

func (s *ReturnParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitReturnParameters(s)
	}
}




func (p *SolidityParser) ReturnParameters() (localctx IReturnParametersContext) {
	this := p
	_ = this

	localctx = NewReturnParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SolidityParserRULE_returnParameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.Match(SolidityParserT__29)
	}
	{
		p.SetState(390)
		p.ParameterList()
	}



	return localctx
}


// IModifierListContext is an interface to support dynamic dispatch.
type IModifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierListContext differentiates from other interfaces.
	IsModifierListContext()
}

type ModifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierListContext() *ModifierListContext {
	var p = new(ModifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierList
	return p
}

func (*ModifierListContext) IsModifierListContext() {}

func NewModifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierListContext {
	var p = new(ModifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_modifierList

	return p
}

func (s *ModifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierListContext) AllModifierInvocation() []IModifierInvocationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			len++
		}
	}

	tst := make([]IModifierInvocationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierInvocationContext); ok {
			tst[i] = t.(IModifierInvocationContext)
			i++
		}
	}

	return tst
}

func (s *ModifierListContext) ModifierInvocation(i int) IModifierInvocationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierInvocationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierInvocationContext)
}

func (s *ModifierListContext) AllStateMutability() []IStateMutabilityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			len++
		}
	}

	tst := make([]IStateMutabilityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStateMutabilityContext); ok {
			tst[i] = t.(IStateMutabilityContext)
			i++
		}
	}

	return tst
}

func (s *ModifierListContext) StateMutability(i int) IStateMutabilityContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStateMutabilityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStateMutabilityContext)
}

func (s *ModifierListContext) AllExternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserExternalKeyword)
}

func (s *ModifierListContext) ExternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserExternalKeyword, i)
}

func (s *ModifierListContext) AllPublicKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPublicKeyword)
}

func (s *ModifierListContext) PublicKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPublicKeyword, i)
}

func (s *ModifierListContext) AllInternalKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserInternalKeyword)
}

func (s *ModifierListContext) InternalKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserInternalKeyword, i)
}

func (s *ModifierListContext) AllPrivateKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserPrivateKeyword)
}

func (s *ModifierListContext) PrivateKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserPrivateKeyword, i)
}

func (s *ModifierListContext) AllVirtualKeyword() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserVirtualKeyword)
}

func (s *ModifierListContext) VirtualKeyword(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserVirtualKeyword, i)
}

func (s *ModifierListContext) AllOverrideSpecifier() []IOverrideSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IOverrideSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOverrideSpecifierContext); ok {
			tst[i] = t.(IOverrideSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifierListContext) OverrideSpecifier(i int) IOverrideSpecifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverrideSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverrideSpecifierContext)
}

func (s *ModifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ModifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterModifierList(s)
	}
}

func (s *ModifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitModifierList(s)
	}
}




func (p *SolidityParser) ModifierList() (localctx IModifierListContext) {
	this := p
	_ = this

	localctx = NewModifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SolidityParserRULE_modifierList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(400)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SolidityParserT__12, SolidityParserT__39, SolidityParserT__51, SolidityParserIdentifier:
				{
					p.SetState(392)
					p.ModifierInvocation()
				}


			case SolidityParserConstantKeyword, SolidityParserPayableKeyword, SolidityParserPureKeyword, SolidityParserViewKeyword:
				{
					p.SetState(393)
					p.StateMutability()
				}


			case SolidityParserExternalKeyword:
				{
					p.SetState(394)
					p.Match(SolidityParserExternalKeyword)
				}


			case SolidityParserPublicKeyword:
				{
					p.SetState(395)
					p.Match(SolidityParserPublicKeyword)
				}


			case SolidityParserInternalKeyword:
				{
					p.SetState(396)
					p.Match(SolidityParserInternalKeyword)
				}


			case SolidityParserPrivateKeyword:
				{
					p.SetState(397)
					p.Match(SolidityParserPrivateKeyword)
				}


			case SolidityParserVirtualKeyword:
				{
					p.SetState(398)
					p.Match(SolidityParserVirtualKeyword)
				}


			case SolidityParserT__23:
				{
					p.SetState(399)
					p.OverrideSpecifier()
				}



			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())
	}



	return localctx
}


// IModifierInvocationContext is an interface to support dynamic dispatch.
type IModifierInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierInvocationContext differentiates from other interfaces.
	IsModifierInvocationContext()
}

type ModifierInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierInvocationContext() *ModifierInvocationContext {
	var p = new(ModifierInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_modifierInvocation
	return p
}

func (*ModifierInvocationContext) IsModifierInvocationContext() {}

func NewModifierInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierInvocationContext {
	var p = new(ModifierInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_modifierInvocation

	return p
}

func (s *ModifierInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierInvocationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifierInvocationContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ModifierInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ModifierInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterModifierInvocation(s)
	}
}

func (s *ModifierInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitModifierInvocation(s)
	}
}




func (p *SolidityParser) ModifierInvocation() (localctx IModifierInvocationContext) {
	this := p
	_ = this

	localctx = NewModifierInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SolidityParserRULE_modifierInvocation)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)
		p.Identifier()
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(406)
			p.Match(SolidityParserT__21)
		}
		p.SetState(408)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__21))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
			{
				p.SetState(407)
				p.ExpressionList()
			}

		}
		{
			p.SetState(410)
			p.Match(SolidityParserT__22)
		}


	}



	return localctx
}


// IEventDefinitionContext is an interface to support dynamic dispatch.
type IEventDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEventDefinitionContext differentiates from other interfaces.
	IsEventDefinitionContext()
}

type EventDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventDefinitionContext() *EventDefinitionContext {
	var p = new(EventDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_eventDefinition
	return p
}

func (*EventDefinitionContext) IsEventDefinitionContext() {}

func NewEventDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventDefinitionContext {
	var p = new(EventDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_eventDefinition

	return p
}

func (s *EventDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EventDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EventDefinitionContext) EventParameterList() IEventParameterListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventParameterListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventParameterListContext)
}

func (s *EventDefinitionContext) AnonymousKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserAnonymousKeyword, 0)
}

func (s *EventDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EventDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEventDefinition(s)
	}
}

func (s *EventDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEventDefinition(s)
	}
}




func (p *SolidityParser) EventDefinition() (localctx IEventDefinitionContext) {
	this := p
	_ = this

	localctx = NewEventDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SolidityParserRULE_eventDefinition)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(413)
		p.Match(SolidityParserT__30)
	}
	{
		p.SetState(414)
		p.Identifier()
	}
	{
		p.SetState(415)
		p.EventParameterList()
	}
	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserAnonymousKeyword {
		{
			p.SetState(416)
			p.Match(SolidityParserAnonymousKeyword)
		}

	}
	{
		p.SetState(419)
		p.Match(SolidityParserT__1)
	}



	return localctx
}


// IEnumDefinitionContext is an interface to support dynamic dispatch.
type IEnumDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumDefinitionContext differentiates from other interfaces.
	IsEnumDefinitionContext()
}

type EnumDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDefinitionContext() *EnumDefinitionContext {
	var p = new(EnumDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_enumDefinition
	return p
}

func (*EnumDefinitionContext) IsEnumDefinitionContext() {}

func NewEnumDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDefinitionContext {
	var p = new(EnumDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_enumDefinition

	return p
}

func (s *EnumDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumDefinitionContext) AllEnumValue() []IEnumValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumValueContext); ok {
			len++
		}
	}

	tst := make([]IEnumValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumValueContext); ok {
			tst[i] = t.(IEnumValueContext)
			i++
		}
	}

	return tst
}

func (s *EnumDefinitionContext) EnumValue(i int) IEnumValueContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueContext)
}

func (s *EnumDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnumDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEnumDefinition(s)
	}
}

func (s *EnumDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEnumDefinition(s)
	}
}




func (p *SolidityParser) EnumDefinition() (localctx IEnumDefinitionContext) {
	this := p
	_ = this

	localctx = NewEnumDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SolidityParserRULE_enumDefinition)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(421)
		p.Match(SolidityParserT__31)
	}
	{
		p.SetState(422)
		p.Identifier()
	}
	{
		p.SetState(423)
		p.Match(SolidityParserT__13)
	}
	p.SetState(425)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__12 || _la == SolidityParserT__39 || _la == SolidityParserT__51 || _la == SolidityParserIdentifier {
		{
			p.SetState(424)
			p.EnumValue()
		}

	}
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == SolidityParserT__14 {
		{
			p.SetState(427)
			p.Match(SolidityParserT__14)
		}
		{
			p.SetState(428)
			p.EnumValue()
		}


		p.SetState(433)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(434)
		p.Match(SolidityParserT__15)
	}



	return localctx
}


// IEnumValueContext is an interface to support dynamic dispatch.
type IEnumValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumValueContext differentiates from other interfaces.
	IsEnumValueContext()
}

type EnumValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueContext() *EnumValueContext {
	var p = new(EnumValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_enumValue
	return p
}

func (*EnumValueContext) IsEnumValueContext() {}

func NewEnumValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueContext {
	var p = new(EnumValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_enumValue

	return p
}

func (s *EnumValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnumValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEnumValue(s)
	}
}

func (s *EnumValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEnumValue(s)
	}
}




func (p *SolidityParser) EnumValue() (localctx IEnumValueContext) {
	this := p
	_ = this

	localctx = NewEnumValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SolidityParserRULE_enumValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(436)
		p.Identifier()
	}



	return localctx
}


// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_parameterList
	return p
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllParameter() []IParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterContext); ok {
			len++
		}
	}

	tst := make([]IParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterContext); ok {
			tst[i] = t.(IParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) Parameter(i int) IParameterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitParameterList(s)
	}
}




func (p *SolidityParser) ParameterList() (localctx IParameterListContext) {
	this := p
	_ = this

	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SolidityParserRULE_parameterList)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(438)
		p.Match(SolidityParserT__21)
	}
	p.SetState(447)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__12 || _la == SolidityParserT__28 || ((((_la - 36)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 36))) & ((1 << (SolidityParserT__35 - 36)) | (1 << (SolidityParserT__39 - 36)) | (1 << (SolidityParserT__50 - 36)) | (1 << (SolidityParserT__51 - 36)) | (1 << (SolidityParserT__52 - 36)) | (1 << (SolidityParserT__53 - 36)) | (1 << (SolidityParserT__54 - 36)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserIdentifier - 93)))) != 0) {
		{
			p.SetState(439)
			p.Parameter()
		}
		p.SetState(444)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == SolidityParserT__14 {
			{
				p.SetState(440)
				p.Match(SolidityParserT__14)
			}
			{
				p.SetState(441)
				p.Parameter()
			}


			p.SetState(446)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(449)
		p.Match(SolidityParserT__22)
	}



	return localctx
}


// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ParameterContext) StorageLocation() IStorageLocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageLocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageLocationContext)
}

func (s *ParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitParameter(s)
	}
}




func (p *SolidityParser) Parameter() (localctx IParameterContext) {
	this := p
	_ = this

	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SolidityParserRULE_parameter)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.typeName(0)
	}
	p.SetState(453)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(452)
			p.StorageLocation()
		}


	}
	p.SetState(456)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__12 || _la == SolidityParserT__39 || _la == SolidityParserT__51 || _la == SolidityParserIdentifier {
		{
			p.SetState(455)
			p.Identifier()
		}

	}



	return localctx
}


// IEventParameterListContext is an interface to support dynamic dispatch.
type IEventParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEventParameterListContext differentiates from other interfaces.
	IsEventParameterListContext()
}

type EventParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventParameterListContext() *EventParameterListContext {
	var p = new(EventParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_eventParameterList
	return p
}

func (*EventParameterListContext) IsEventParameterListContext() {}

func NewEventParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventParameterListContext {
	var p = new(EventParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_eventParameterList

	return p
}

func (s *EventParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *EventParameterListContext) AllEventParameter() []IEventParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEventParameterContext); ok {
			len++
		}
	}

	tst := make([]IEventParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEventParameterContext); ok {
			tst[i] = t.(IEventParameterContext)
			i++
		}
	}

	return tst
}

func (s *EventParameterListContext) EventParameter(i int) IEventParameterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventParameterContext)
}

func (s *EventParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EventParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEventParameterList(s)
	}
}

func (s *EventParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEventParameterList(s)
	}
}




func (p *SolidityParser) EventParameterList() (localctx IEventParameterListContext) {
	this := p
	_ = this

	localctx = NewEventParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SolidityParserRULE_eventParameterList)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.Match(SolidityParserT__21)
	}
	p.SetState(467)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__12 || _la == SolidityParserT__28 || ((((_la - 36)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 36))) & ((1 << (SolidityParserT__35 - 36)) | (1 << (SolidityParserT__39 - 36)) | (1 << (SolidityParserT__50 - 36)) | (1 << (SolidityParserT__51 - 36)) | (1 << (SolidityParserT__52 - 36)) | (1 << (SolidityParserT__53 - 36)) | (1 << (SolidityParserT__54 - 36)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserIdentifier - 93)))) != 0) {
		{
			p.SetState(459)
			p.EventParameter()
		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == SolidityParserT__14 {
			{
				p.SetState(460)
				p.Match(SolidityParserT__14)
			}
			{
				p.SetState(461)
				p.EventParameter()
			}


			p.SetState(466)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(469)
		p.Match(SolidityParserT__22)
	}



	return localctx
}


// IEventParameterContext is an interface to support dynamic dispatch.
type IEventParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEventParameterContext differentiates from other interfaces.
	IsEventParameterContext()
}

type EventParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventParameterContext() *EventParameterContext {
	var p = new(EventParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_eventParameter
	return p
}

func (*EventParameterContext) IsEventParameterContext() {}

func NewEventParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventParameterContext {
	var p = new(EventParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_eventParameter

	return p
}

func (s *EventParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *EventParameterContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *EventParameterContext) IndexedKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserIndexedKeyword, 0)
}

func (s *EventParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EventParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EventParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEventParameter(s)
	}
}

func (s *EventParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEventParameter(s)
	}
}




func (p *SolidityParser) EventParameter() (localctx IEventParameterContext) {
	this := p
	_ = this

	localctx = NewEventParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SolidityParserRULE_eventParameter)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.typeName(0)
	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserIndexedKeyword {
		{
			p.SetState(472)
			p.Match(SolidityParserIndexedKeyword)
		}

	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__12 || _la == SolidityParserT__39 || _la == SolidityParserT__51 || _la == SolidityParserIdentifier {
		{
			p.SetState(475)
			p.Identifier()
		}

	}



	return localctx
}


// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *VariableDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclarationContext) StorageLocation() IStorageLocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageLocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageLocationContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}




func (p *SolidityParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SolidityParserRULE_variableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(478)
		p.typeName(0)
	}
	p.SetState(480)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(479)
			p.StorageLocation()
		}


	}
	{
		p.SetState(482)
		p.Identifier()
	}



	return localctx
}


// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_typeName
	return p
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *TypeNameContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *TypeNameContext) Mapping() IMappingContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingContext)
}

func (s *TypeNameContext) FunctionTypeName() IFunctionTypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeNameContext)
}

func (s *TypeNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitTypeName(s)
	}
}





func (p *SolidityParser) TypeName() (localctx ITypeNameContext) {
	return p.typeName(0)
}

func (p *SolidityParser) typeName(_p int) (localctx ITypeNameContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITypeNameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 60
	p.EnterRecursionRule(localctx, 60, SolidityParserRULE_typeName, _p)
	var _la int


	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(485)
			p.ElementaryTypeName()
		}


	case 2:
		{
			p.SetState(486)
			p.UserDefinedTypeName()
		}


	case 3:
		{
			p.SetState(487)
			p.Mapping()
		}


	case 4:
		{
			p.SetState(488)
			p.FunctionTypeName()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(499)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTypeNameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_typeName)
			p.SetState(491)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(492)
				p.Match(SolidityParserT__32)
			}
			p.SetState(494)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__21))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
				{
					p.SetState(493)
					p.expression(0)
				}

			}
			{
				p.SetState(496)
				p.Match(SolidityParserT__33)
			}


		}
		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
	}



	return localctx
}


// IUserDefinedTypeNameContext is an interface to support dynamic dispatch.
type IUserDefinedTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUserDefinedTypeNameContext differentiates from other interfaces.
	IsUserDefinedTypeNameContext()
}

type UserDefinedTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserDefinedTypeNameContext() *UserDefinedTypeNameContext {
	var p = new(UserDefinedTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_userDefinedTypeName
	return p
}

func (*UserDefinedTypeNameContext) IsUserDefinedTypeNameContext() {}

func NewUserDefinedTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDefinedTypeNameContext {
	var p = new(UserDefinedTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_userDefinedTypeName

	return p
}

func (s *UserDefinedTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *UserDefinedTypeNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UserDefinedTypeNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UserDefinedTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDefinedTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UserDefinedTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterUserDefinedTypeName(s)
	}
}

func (s *UserDefinedTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitUserDefinedTypeName(s)
	}
}




func (p *SolidityParser) UserDefinedTypeName() (localctx IUserDefinedTypeNameContext) {
	this := p
	_ = this

	localctx = NewUserDefinedTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SolidityParserRULE_userDefinedTypeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(502)
		p.Identifier()
	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(503)
				p.Match(SolidityParserT__34)
			}
			{
				p.SetState(504)
				p.Identifier()
			}


		}
		p.SetState(509)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())
	}



	return localctx
}


// IMappingContext is an interface to support dynamic dispatch.
type IMappingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMappingContext differentiates from other interfaces.
	IsMappingContext()
}

type MappingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMappingContext() *MappingContext {
	var p = new(MappingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_mapping
	return p
}

func (*MappingContext) IsMappingContext() {}

func NewMappingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingContext {
	var p = new(MappingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_mapping

	return p
}

func (s *MappingContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MappingContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *MappingContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *MappingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MappingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterMapping(s)
	}
}

func (s *MappingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitMapping(s)
	}
}




func (p *SolidityParser) Mapping() (localctx IMappingContext) {
	this := p
	_ = this

	localctx = NewMappingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SolidityParserRULE_mapping)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(510)
		p.Match(SolidityParserT__35)
	}
	{
		p.SetState(511)
		p.Match(SolidityParserT__21)
	}
	p.SetState(514)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(512)
			p.ElementaryTypeName()
		}


	case 2:
		{
			p.SetState(513)
			p.UserDefinedTypeName()
		}

	}
	{
		p.SetState(516)
		p.Match(SolidityParserT__36)
	}
	{
		p.SetState(517)
		p.typeName(0)
	}
	{
		p.SetState(518)
		p.Match(SolidityParserT__22)
	}



	return localctx
}


// IFunctionTypeNameContext is an interface to support dynamic dispatch.
type IFunctionTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionTypeNameContext differentiates from other interfaces.
	IsFunctionTypeNameContext()
}

type FunctionTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeNameContext() *FunctionTypeNameContext {
	var p = new(FunctionTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_functionTypeName
	return p
}

func (*FunctionTypeNameContext) IsFunctionTypeNameContext() {}

func NewFunctionTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeNameContext {
	var p = new(FunctionTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionTypeName

	return p
}

func (s *FunctionTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeNameContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionTypeNameContext) ModifierList() IModifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *FunctionTypeNameContext) ReturnParameters() IReturnParametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnParametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnParametersContext)
}

func (s *FunctionTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionTypeName(s)
	}
}

func (s *FunctionTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionTypeName(s)
	}
}




func (p *SolidityParser) FunctionTypeName() (localctx IFunctionTypeNameContext) {
	this := p
	_ = this

	localctx = NewFunctionTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SolidityParserRULE_functionTypeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(520)
		p.Match(SolidityParserT__28)
	}
	{
		p.SetState(521)
		p.ParameterList()
	}
	{
		p.SetState(522)
		p.ModifierList()
	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(523)
			p.ReturnParameters()
		}


	}



	return localctx
}


// IStorageLocationContext is an interface to support dynamic dispatch.
type IStorageLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStorageLocationContext differentiates from other interfaces.
	IsStorageLocationContext()
}

type StorageLocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorageLocationContext() *StorageLocationContext {
	var p = new(StorageLocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_storageLocation
	return p
}

func (*StorageLocationContext) IsStorageLocationContext() {}

func NewStorageLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageLocationContext {
	var p = new(StorageLocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_storageLocation

	return p
}

func (s *StorageLocationContext) GetParser() antlr.Parser { return s.parser }
func (s *StorageLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StorageLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStorageLocation(s)
	}
}

func (s *StorageLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStorageLocation(s)
	}
}




func (p *SolidityParser) StorageLocation() (localctx IStorageLocationContext) {
	this := p
	_ = this

	localctx = NewStorageLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SolidityParserRULE_storageLocation)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(526)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 38)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 38))) & ((1 << (SolidityParserT__37 - 38)) | (1 << (SolidityParserT__38 - 38)) | (1 << (SolidityParserT__39 - 38)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IStateMutabilityContext is an interface to support dynamic dispatch.
type IStateMutabilityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStateMutabilityContext differentiates from other interfaces.
	IsStateMutabilityContext()
}

type StateMutabilityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStateMutabilityContext() *StateMutabilityContext {
	var p = new(StateMutabilityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_stateMutability
	return p
}

func (*StateMutabilityContext) IsStateMutabilityContext() {}

func NewStateMutabilityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StateMutabilityContext {
	var p = new(StateMutabilityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_stateMutability

	return p
}

func (s *StateMutabilityContext) GetParser() antlr.Parser { return s.parser }

func (s *StateMutabilityContext) PureKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPureKeyword, 0)
}

func (s *StateMutabilityContext) ConstantKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserConstantKeyword, 0)
}

func (s *StateMutabilityContext) ViewKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserViewKeyword, 0)
}

func (s *StateMutabilityContext) PayableKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayableKeyword, 0)
}

func (s *StateMutabilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StateMutabilityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StateMutabilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStateMutability(s)
	}
}

func (s *StateMutabilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStateMutability(s)
	}
}




func (p *SolidityParser) StateMutability() (localctx IStateMutabilityContext) {
	this := p
	_ = this

	localctx = NewStateMutabilityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SolidityParserRULE_stateMutability)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(528)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 106)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 106))) & ((1 << (SolidityParserConstantKeyword - 106)) | (1 << (SolidityParserPayableKeyword - 106)) | (1 << (SolidityParserPureKeyword - 106)) | (1 << (SolidityParserViewKeyword - 106)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitBlock(s)
	}
}




func (p *SolidityParser) Block() (localctx IBlockContext) {
	this := p
	_ = this

	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SolidityParserRULE_block)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.Match(SolidityParserT__13)
	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__13) | (1 << SolidityParserT__21) | (1 << SolidityParserT__25) | (1 << SolidityParserT__28))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__35 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__40 - 33)) | (1 << (SolidityParserT__42 - 33)) | (1 << (SolidityParserT__44 - 33)) | (1 << (SolidityParserT__45 - 33)) | (1 << (SolidityParserT__46 - 33)) | (1 << (SolidityParserT__47 - 33)) | (1 << (SolidityParserT__48 - 33)) | (1 << (SolidityParserT__49 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserBreakKeyword - 93)) | (1 << (SolidityParserContinueKeyword - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
		{
			p.SetState(531)
			p.Statement()
		}


		p.SetState(536)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(537)
		p.Match(SolidityParserT__15)
	}



	return localctx
}


// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) InlineAssemblyStatement() IInlineAssemblyStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineAssemblyStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineAssemblyStatementContext)
}

func (s *StatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) EmitStatement() IEmitStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmitStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmitStatementContext)
}

func (s *StatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStatement(s)
	}
}




func (p *SolidityParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SolidityParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(552)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__40:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(539)
			p.IfStatement()
		}


	case SolidityParserT__42:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(540)
			p.TryStatement()
		}


	case SolidityParserT__44:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(541)
			p.WhileStatement()
		}


	case SolidityParserT__25:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(542)
			p.ForStatement()
		}


	case SolidityParserT__13:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(543)
			p.Block()
		}


	case SolidityParserT__45:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(544)
			p.InlineAssemblyStatement()
		}


	case SolidityParserT__46:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(545)
			p.DoWhileStatement()
		}


	case SolidityParserContinueKeyword:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(546)
			p.ContinueStatement()
		}


	case SolidityParserBreakKeyword:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(547)
			p.BreakStatement()
		}


	case SolidityParserT__47:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(548)
			p.ReturnStatement()
		}


	case SolidityParserT__48:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(549)
			p.ThrowStatement()
		}


	case SolidityParserT__49:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(550)
			p.EmitStatement()
		}


	case SolidityParserT__3, SolidityParserT__12, SolidityParserT__21, SolidityParserT__28, SolidityParserT__32, SolidityParserT__35, SolidityParserT__39, SolidityParserT__50, SolidityParserT__51, SolidityParserT__52, SolidityParserT__53, SolidityParserT__54, SolidityParserT__55, SolidityParserT__56, SolidityParserT__57, SolidityParserT__59, SolidityParserT__60, SolidityParserT__61, SolidityParserT__62, SolidityParserT__63, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserPayableKeyword, SolidityParserTypeKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(551)
			p.SimpleStatement()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}




func (p *SolidityParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	this := p
	_ = this

	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SolidityParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(554)
		p.expression(0)
	}
	{
		p.SetState(555)
		p.Match(SolidityParserT__1)
	}



	return localctx
}


// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitIfStatement(s)
	}
}




func (p *SolidityParser) IfStatement() (localctx IIfStatementContext) {
	this := p
	_ = this

	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SolidityParserRULE_ifStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(557)
		p.Match(SolidityParserT__40)
	}
	{
		p.SetState(558)
		p.Match(SolidityParserT__21)
	}
	{
		p.SetState(559)
		p.expression(0)
	}
	{
		p.SetState(560)
		p.Match(SolidityParserT__22)
	}
	{
		p.SetState(561)
		p.Statement()
	}
	p.SetState(564)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(562)
			p.Match(SolidityParserT__41)
		}
		{
			p.SetState(563)
			p.Statement()
		}


	}



	return localctx
}


// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_tryStatement
	return p
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) ReturnParameters() IReturnParametersContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnParametersContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnParametersContext)
}

func (s *TryStatementContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *TryStatementContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitTryStatement(s)
	}
}




func (p *SolidityParser) TryStatement() (localctx ITryStatementContext) {
	this := p
	_ = this

	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SolidityParserRULE_tryStatement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		p.Match(SolidityParserT__42)
	}
	{
		p.SetState(567)
		p.expression(0)
	}
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__29 {
		{
			p.SetState(568)
			p.ReturnParameters()
		}

	}
	{
		p.SetState(571)
		p.Block()
	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == SolidityParserT__43 {
		{
			p.SetState(572)
			p.CatchClause()
		}


		p.SetState(575)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_catchClause
	return p
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *CatchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitCatchClause(s)
	}
}




func (p *SolidityParser) CatchClause() (localctx ICatchClauseContext) {
	this := p
	_ = this

	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SolidityParserRULE_catchClause)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(577)
		p.Match(SolidityParserT__43)
	}
	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__12 || _la == SolidityParserT__21 || _la == SolidityParserT__39 || _la == SolidityParserT__51 || _la == SolidityParserIdentifier {
		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == SolidityParserT__12 || _la == SolidityParserT__39 || _la == SolidityParserT__51 || _la == SolidityParserIdentifier {
			{
				p.SetState(578)
				p.Identifier()
			}

		}
		{
			p.SetState(581)
			p.ParameterList()
		}

	}
	{
		p.SetState(584)
		p.Block()
	}



	return localctx
}


// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}




func (p *SolidityParser) WhileStatement() (localctx IWhileStatementContext) {
	this := p
	_ = this

	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SolidityParserRULE_whileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.Match(SolidityParserT__44)
	}
	{
		p.SetState(587)
		p.Match(SolidityParserT__21)
	}
	{
		p.SetState(588)
		p.expression(0)
	}
	{
		p.SetState(589)
		p.Match(SolidityParserT__22)
	}
	{
		p.SetState(590)
		p.Statement()
	}



	return localctx
}


// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_forStatement
	return p
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *ForStatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitForStatement(s)
	}
}




func (p *SolidityParser) ForStatement() (localctx IForStatementContext) {
	this := p
	_ = this

	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SolidityParserRULE_forStatement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)
		p.Match(SolidityParserT__25)
	}
	{
		p.SetState(593)
		p.Match(SolidityParserT__21)
	}
	p.SetState(596)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__3, SolidityParserT__12, SolidityParserT__21, SolidityParserT__28, SolidityParserT__32, SolidityParserT__35, SolidityParserT__39, SolidityParserT__50, SolidityParserT__51, SolidityParserT__52, SolidityParserT__53, SolidityParserT__54, SolidityParserT__55, SolidityParserT__56, SolidityParserT__57, SolidityParserT__59, SolidityParserT__60, SolidityParserT__61, SolidityParserT__62, SolidityParserT__63, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserPayableKeyword, SolidityParserTypeKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		{
			p.SetState(594)
			p.SimpleStatement()
		}


	case SolidityParserT__1:
		{
			p.SetState(595)
			p.Match(SolidityParserT__1)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(600)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__3, SolidityParserT__12, SolidityParserT__21, SolidityParserT__32, SolidityParserT__39, SolidityParserT__50, SolidityParserT__51, SolidityParserT__52, SolidityParserT__53, SolidityParserT__54, SolidityParserT__55, SolidityParserT__56, SolidityParserT__57, SolidityParserT__59, SolidityParserT__60, SolidityParserT__61, SolidityParserT__62, SolidityParserT__63, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserPayableKeyword, SolidityParserTypeKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		{
			p.SetState(598)
			p.ExpressionStatement()
		}


	case SolidityParserT__1:
		{
			p.SetState(599)
			p.Match(SolidityParserT__1)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__21))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
		{
			p.SetState(602)
			p.expression(0)
		}

	}
	{
		p.SetState(605)
		p.Match(SolidityParserT__22)
	}
	{
		p.SetState(606)
		p.Statement()
	}



	return localctx
}


// ISimpleStatementContext is an interface to support dynamic dispatch.
type ISimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleStatementContext differentiates from other interfaces.
	IsSimpleStatementContext()
}

type SimpleStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStatementContext() *SimpleStatementContext {
	var p = new(SimpleStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_simpleStatement
	return p
}

func (*SimpleStatementContext) IsSimpleStatementContext() {}

func NewSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStatementContext {
	var p = new(SimpleStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_simpleStatement

	return p
}

func (s *SimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStatementContext) VariableDeclarationStatement() IVariableDeclarationStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationStatementContext)
}

func (s *SimpleStatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *SimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitSimpleStatement(s)
	}
}




func (p *SolidityParser) SimpleStatement() (localctx ISimpleStatementContext) {
	this := p
	_ = this

	localctx = NewSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SolidityParserRULE_simpleStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(608)
			p.VariableDeclarationStatement()
		}


	case 2:
		{
			p.SetState(609)
			p.ExpressionStatement()
		}

	}



	return localctx
}


// IInlineAssemblyStatementContext is an interface to support dynamic dispatch.
type IInlineAssemblyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInlineAssemblyStatementContext differentiates from other interfaces.
	IsInlineAssemblyStatementContext()
}

type InlineAssemblyStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineAssemblyStatementContext() *InlineAssemblyStatementContext {
	var p = new(InlineAssemblyStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_inlineAssemblyStatement
	return p
}

func (*InlineAssemblyStatementContext) IsInlineAssemblyStatementContext() {}

func NewInlineAssemblyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineAssemblyStatementContext {
	var p = new(InlineAssemblyStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_inlineAssemblyStatement

	return p
}

func (s *InlineAssemblyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineAssemblyStatementContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *InlineAssemblyStatementContext) StringLiteralFragment() antlr.TerminalNode {
	return s.GetToken(SolidityParserStringLiteralFragment, 0)
}

func (s *InlineAssemblyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineAssemblyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InlineAssemblyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterInlineAssemblyStatement(s)
	}
}

func (s *InlineAssemblyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitInlineAssemblyStatement(s)
	}
}




func (p *SolidityParser) InlineAssemblyStatement() (localctx IInlineAssemblyStatementContext) {
	this := p
	_ = this

	localctx = NewInlineAssemblyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SolidityParserRULE_inlineAssemblyStatement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		p.Match(SolidityParserT__45)
	}
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserStringLiteralFragment {
		{
			p.SetState(613)
			p.Match(SolidityParserStringLiteralFragment)
		}

	}
	{
		p.SetState(616)
		p.AssemblyBlock()
	}



	return localctx
}


// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_doWhileStatement
	return p
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoWhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DoWhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterDoWhileStatement(s)
	}
}

func (s *DoWhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitDoWhileStatement(s)
	}
}




func (p *SolidityParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	this := p
	_ = this

	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SolidityParserRULE_doWhileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.Match(SolidityParserT__46)
	}
	{
		p.SetState(619)
		p.Statement()
	}
	{
		p.SetState(620)
		p.Match(SolidityParserT__44)
	}
	{
		p.SetState(621)
		p.Match(SolidityParserT__21)
	}
	{
		p.SetState(622)
		p.expression(0)
	}
	{
		p.SetState(623)
		p.Match(SolidityParserT__22)
	}
	{
		p.SetState(624)
		p.Match(SolidityParserT__1)
	}



	return localctx
}


// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) ContinueKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserContinueKeyword, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}




func (p *SolidityParser) ContinueStatement() (localctx IContinueStatementContext) {
	this := p
	_ = this

	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SolidityParserRULE_continueStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(626)
		p.Match(SolidityParserContinueKeyword)
	}
	{
		p.SetState(627)
		p.Match(SolidityParserT__1)
	}



	return localctx
}


// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BreakKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserBreakKeyword, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}




func (p *SolidityParser) BreakStatement() (localctx IBreakStatementContext) {
	this := p
	_ = this

	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SolidityParserRULE_breakStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(629)
		p.Match(SolidityParserBreakKeyword)
	}
	{
		p.SetState(630)
		p.Match(SolidityParserT__1)
	}



	return localctx
}


// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}




func (p *SolidityParser) ReturnStatement() (localctx IReturnStatementContext) {
	this := p
	_ = this

	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SolidityParserRULE_returnStatement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(632)
		p.Match(SolidityParserT__47)
	}
	p.SetState(634)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__21))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
		{
			p.SetState(633)
			p.expression(0)
		}

	}
	{
		p.SetState(636)
		p.Match(SolidityParserT__1)
	}



	return localctx
}


// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_throwStatement
	return p
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }
func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}




func (p *SolidityParser) ThrowStatement() (localctx IThrowStatementContext) {
	this := p
	_ = this

	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SolidityParserRULE_throwStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(638)
		p.Match(SolidityParserT__48)
	}
	{
		p.SetState(639)
		p.Match(SolidityParserT__1)
	}



	return localctx
}


// IEmitStatementContext is an interface to support dynamic dispatch.
type IEmitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmitStatementContext differentiates from other interfaces.
	IsEmitStatementContext()
}

type EmitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmitStatementContext() *EmitStatementContext {
	var p = new(EmitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_emitStatement
	return p
}

func (*EmitStatementContext) IsEmitStatementContext() {}

func NewEmitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmitStatementContext {
	var p = new(EmitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_emitStatement

	return p
}

func (s *EmitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EmitStatementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *EmitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EmitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterEmitStatement(s)
	}
}

func (s *EmitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitEmitStatement(s)
	}
}




func (p *SolidityParser) EmitStatement() (localctx IEmitStatementContext) {
	this := p
	_ = this

	localctx = NewEmitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SolidityParserRULE_emitStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.Match(SolidityParserT__49)
	}
	{
		p.SetState(642)
		p.FunctionCall()
	}
	{
		p.SetState(643)
		p.Match(SolidityParserT__1)
	}



	return localctx
}


// IVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type IVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationStatementContext differentiates from other interfaces.
	IsVariableDeclarationStatementContext()
}

type VariableDeclarationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationStatementContext() *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationStatement
	return p
}

func (*VariableDeclarationStatementContext) IsVariableDeclarationStatementContext() {}

func NewVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclarationStatement

	return p
}

func (s *VariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *VariableDeclarationStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *VariableDeclarationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VariableDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVariableDeclarationStatement(s)
	}
}

func (s *VariableDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVariableDeclarationStatement(s)
	}
}




func (p *SolidityParser) VariableDeclarationStatement() (localctx IVariableDeclarationStatementContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SolidityParserRULE_variableDeclarationStatement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(645)
			p.Match(SolidityParserT__50)
		}
		{
			p.SetState(646)
			p.IdentifierList()
		}


	case 2:
		{
			p.SetState(647)
			p.VariableDeclaration()
		}


	case 3:
		{
			p.SetState(648)
			p.Match(SolidityParserT__21)
		}
		{
			p.SetState(649)
			p.VariableDeclarationList()
		}
		{
			p.SetState(650)
			p.Match(SolidityParserT__22)
		}

	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__8 {
		{
			p.SetState(654)
			p.Match(SolidityParserT__8)
		}
		{
			p.SetState(655)
			p.expression(0)
		}

	}
	{
		p.SetState(658)
		p.Match(SolidityParserT__1)
	}



	return localctx
}


// IVariableDeclarationListContext is an interface to support dynamic dispatch.
type IVariableDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationListContext differentiates from other interfaces.
	IsVariableDeclarationListContext()
}

type VariableDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationListContext() *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_variableDeclarationList
	return p
}

func (*VariableDeclarationListContext) IsVariableDeclarationListContext() {}

func NewVariableDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_variableDeclarationList

	return p
}

func (s *VariableDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationListContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationListContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VariableDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitVariableDeclarationList(s)
	}
}




func (p *SolidityParser) VariableDeclarationList() (localctx IVariableDeclarationListContext) {
	this := p
	_ = this

	localctx = NewVariableDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SolidityParserRULE_variableDeclarationList)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__12 || _la == SolidityParserT__28 || ((((_la - 36)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 36))) & ((1 << (SolidityParserT__35 - 36)) | (1 << (SolidityParserT__39 - 36)) | (1 << (SolidityParserT__50 - 36)) | (1 << (SolidityParserT__51 - 36)) | (1 << (SolidityParserT__52 - 36)) | (1 << (SolidityParserT__53 - 36)) | (1 << (SolidityParserT__54 - 36)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserIdentifier - 93)))) != 0) {
		{
			p.SetState(660)
			p.VariableDeclaration()
		}

	}
	p.SetState(669)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == SolidityParserT__14 {
		{
			p.SetState(663)
			p.Match(SolidityParserT__14)
		}
		p.SetState(665)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == SolidityParserT__12 || _la == SolidityParserT__28 || ((((_la - 36)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 36))) & ((1 << (SolidityParserT__35 - 36)) | (1 << (SolidityParserT__39 - 36)) | (1 << (SolidityParserT__50 - 36)) | (1 << (SolidityParserT__51 - 36)) | (1 << (SolidityParserT__52 - 36)) | (1 << (SolidityParserT__53 - 36)) | (1 << (SolidityParserT__54 - 36)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserIdentifier - 93)))) != 0) {
			{
				p.SetState(664)
				p.VariableDeclaration()
			}

		}


		p.SetState(671)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_identifierList
	return p
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}




func (p *SolidityParser) IdentifierList() (localctx IIdentifierListContext) {
	this := p
	_ = this

	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SolidityParserRULE_identifierList)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		p.Match(SolidityParserT__21)
	}
	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(674)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == SolidityParserT__12 || _la == SolidityParserT__39 || _la == SolidityParserT__51 || _la == SolidityParserIdentifier {
				{
					p.SetState(673)
					p.Identifier()
				}

			}
			{
				p.SetState(676)
				p.Match(SolidityParserT__14)
			}


		}
		p.SetState(681)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__12 || _la == SolidityParserT__39 || _la == SolidityParserT__51 || _la == SolidityParserIdentifier {
		{
			p.SetState(682)
			p.Identifier()
		}

	}
	{
		p.SetState(685)
		p.Match(SolidityParserT__22)
	}



	return localctx
}


// IElementaryTypeNameContext is an interface to support dynamic dispatch.
type IElementaryTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementaryTypeNameContext differentiates from other interfaces.
	IsElementaryTypeNameContext()
}

type ElementaryTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementaryTypeNameContext() *ElementaryTypeNameContext {
	var p = new(ElementaryTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_elementaryTypeName
	return p
}

func (*ElementaryTypeNameContext) IsElementaryTypeNameContext() {}

func NewElementaryTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementaryTypeNameContext {
	var p = new(ElementaryTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_elementaryTypeName

	return p
}

func (s *ElementaryTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementaryTypeNameContext) PayableKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayableKeyword, 0)
}

func (s *ElementaryTypeNameContext) Int() antlr.TerminalNode {
	return s.GetToken(SolidityParserInt, 0)
}

func (s *ElementaryTypeNameContext) Uint() antlr.TerminalNode {
	return s.GetToken(SolidityParserUint, 0)
}

func (s *ElementaryTypeNameContext) Byte() antlr.TerminalNode {
	return s.GetToken(SolidityParserByte, 0)
}

func (s *ElementaryTypeNameContext) Fixed() antlr.TerminalNode {
	return s.GetToken(SolidityParserFixed, 0)
}

func (s *ElementaryTypeNameContext) Ufixed() antlr.TerminalNode {
	return s.GetToken(SolidityParserUfixed, 0)
}

func (s *ElementaryTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementaryTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElementaryTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterElementaryTypeName(s)
	}
}

func (s *ElementaryTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitElementaryTypeName(s)
	}
}




func (p *SolidityParser) ElementaryTypeName() (localctx IElementaryTypeNameContext) {
	this := p
	_ = this

	localctx = NewElementaryTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SolidityParserRULE_elementaryTypeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(700)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__51:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(687)
			p.Match(SolidityParserT__51)
		}
		p.SetState(689)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(688)
				p.Match(SolidityParserPayableKeyword)
			}


		}


	case SolidityParserT__52:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(691)
			p.Match(SolidityParserT__52)
		}


	case SolidityParserT__53:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(692)
			p.Match(SolidityParserT__53)
		}


	case SolidityParserT__50:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(693)
			p.Match(SolidityParserT__50)
		}


	case SolidityParserInt:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(694)
			p.Match(SolidityParserInt)
		}


	case SolidityParserUint:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(695)
			p.Match(SolidityParserUint)
		}


	case SolidityParserT__54:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(696)
			p.Match(SolidityParserT__54)
		}


	case SolidityParserByte:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(697)
			p.Match(SolidityParserByte)
		}


	case SolidityParserFixed:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(698)
			p.Match(SolidityParserFixed)
		}


	case SolidityParserUfixed:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(699)
			p.Match(SolidityParserUfixed)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ExpressionContext) PayableKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserPayableKeyword, 0)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExpressionContext) NameValueList() INameValueListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameValueListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameValueListContext)
}

func (s *ExpressionContext) FunctionCallArguments() IFunctionCallArgumentsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallArgumentsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallArgumentsContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitExpression(s)
	}
}





func (p *SolidityParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *SolidityParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 112
	p.EnterRecursionRule(localctx, 112, SolidityParserRULE_expression, _p)
	var _la int


	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(703)
			p.Match(SolidityParserT__57)
		}
		{
			p.SetState(704)
			p.typeName(0)
		}


	case 2:
		{
			p.SetState(705)
			p.Match(SolidityParserPayableKeyword)
		}
		{
			p.SetState(706)
			p.Match(SolidityParserT__21)
		}
		{
			p.SetState(707)
			p.expression(0)
		}
		{
			p.SetState(708)
			p.Match(SolidityParserT__22)
		}


	case 3:
		{
			p.SetState(710)
			p.Match(SolidityParserT__21)
		}
		{
			p.SetState(711)
			p.expression(0)
		}
		{
			p.SetState(712)
			p.Match(SolidityParserT__22)
		}


	case 4:
		{
			p.SetState(714)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SolidityParserT__55 || _la == SolidityParserT__56) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(715)
			p.expression(19)
		}


	case 5:
		{
			p.SetState(716)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SolidityParserT__59 || _la == SolidityParserT__60) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(717)
			p.expression(18)
		}


	case 6:
		{
			p.SetState(718)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SolidityParserT__61 || _la == SolidityParserT__62) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(719)
			p.expression(17)
		}


	case 7:
		{
			p.SetState(720)
			p.Match(SolidityParserT__63)
		}
		{
			p.SetState(721)
			p.expression(16)
		}


	case 8:
		{
			p.SetState(722)
			p.Match(SolidityParserT__3)
		}
		{
			p.SetState(723)
			p.expression(15)
		}


	case 9:
		{
			p.SetState(724)
			p.PrimaryExpression()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(802)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(800)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(727)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(728)
					p.Match(SolidityParserT__64)
				}
				{
					p.SetState(729)
					p.expression(15)
				}


			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(730)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(731)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__11 || _la == SolidityParserT__65 || _la == SolidityParserT__66) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(732)
					p.expression(14)
				}


			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(733)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(734)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__59 || _la == SolidityParserT__60) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(735)
					p.expression(13)
				}


			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(736)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(737)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__67 || _la == SolidityParserT__68) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(738)
					p.expression(12)
				}


			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(739)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(740)
					p.Match(SolidityParserT__69)
				}
				{
					p.SetState(741)
					p.expression(11)
				}


			case 6:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(742)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(743)
					p.Match(SolidityParserT__2)
				}
				{
					p.SetState(744)
					p.expression(10)
				}


			case 7:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(745)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(746)
					p.Match(SolidityParserT__70)
				}
				{
					p.SetState(747)
					p.expression(9)
				}


			case 8:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(748)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(749)
					_la = p.GetTokenStream().LA(1)

					if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__4) | (1 << SolidityParserT__5) | (1 << SolidityParserT__6) | (1 << SolidityParserT__7))) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(750)
					p.expression(8)
				}


			case 9:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(751)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(752)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__71 || _la == SolidityParserT__72) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(753)
					p.expression(7)
				}


			case 10:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(754)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(755)
					p.Match(SolidityParserT__73)
				}
				{
					p.SetState(756)
					p.expression(6)
				}


			case 11:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(757)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(758)
					p.Match(SolidityParserT__74)
				}
				{
					p.SetState(759)
					p.expression(5)
				}


			case 12:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(760)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(761)
					p.Match(SolidityParserT__75)
				}
				{
					p.SetState(762)
					p.expression(0)
				}
				{
					p.SetState(763)
					p.Match(SolidityParserT__58)
				}
				{
					p.SetState(764)
					p.expression(4)
				}


			case 13:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(766)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(767)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__8 || ((((_la - 77)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 77))) & ((1 << (SolidityParserT__76 - 77)) | (1 << (SolidityParserT__77 - 77)) | (1 << (SolidityParserT__78 - 77)) | (1 << (SolidityParserT__79 - 77)) | (1 << (SolidityParserT__80 - 77)) | (1 << (SolidityParserT__81 - 77)) | (1 << (SolidityParserT__82 - 77)) | (1 << (SolidityParserT__83 - 77)) | (1 << (SolidityParserT__84 - 77)) | (1 << (SolidityParserT__85 - 77)))) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(768)
					p.expression(3)
				}


			case 14:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(769)

				if !(p.Precpred(p.GetParserRuleContext(), 28)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 28)", ""))
				}
				{
					p.SetState(770)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SolidityParserT__55 || _la == SolidityParserT__56) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


			case 15:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(771)

				if !(p.Precpred(p.GetParserRuleContext(), 26)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 26)", ""))
				}
				{
					p.SetState(772)
					p.Match(SolidityParserT__32)
				}
				p.SetState(774)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__21))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
					{
						p.SetState(773)
						p.expression(0)
					}

				}
				{
					p.SetState(776)
					p.Match(SolidityParserT__33)
				}


			case 16:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(777)

				if !(p.Precpred(p.GetParserRuleContext(), 25)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 25)", ""))
				}
				{
					p.SetState(778)
					p.Match(SolidityParserT__32)
				}
				p.SetState(780)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__21))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
					{
						p.SetState(779)
						p.expression(0)
					}

				}
				{
					p.SetState(782)
					p.Match(SolidityParserT__58)
				}
				p.SetState(784)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__21))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
					{
						p.SetState(783)
						p.expression(0)
					}

				}
				{
					p.SetState(786)
					p.Match(SolidityParserT__33)
				}


			case 17:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(787)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
				}
				{
					p.SetState(788)
					p.Match(SolidityParserT__34)
				}
				{
					p.SetState(789)
					p.Identifier()
				}


			case 18:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(790)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
				}
				{
					p.SetState(791)
					p.Match(SolidityParserT__13)
				}
				{
					p.SetState(792)
					p.NameValueList()
				}
				{
					p.SetState(793)
					p.Match(SolidityParserT__15)
				}


			case 19:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SolidityParserRULE_expression)
				p.SetState(795)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
				}
				{
					p.SetState(796)
					p.Match(SolidityParserT__21)
				}
				{
					p.SetState(797)
					p.FunctionCallArguments()
				}
				{
					p.SetState(798)
					p.Match(SolidityParserT__22)
				}

			}

		}
		p.SetState(804)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext())
	}



	return localctx
}


// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(SolidityParserBooleanLiteral, 0)
}

func (s *PrimaryExpressionContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *PrimaryExpressionContext) HexLiteral() IHexLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexLiteralContext)
}

func (s *PrimaryExpressionContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PrimaryExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimaryExpressionContext) TypeKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserTypeKeyword, 0)
}

func (s *PrimaryExpressionContext) TupleExpression() ITupleExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleExpressionContext)
}

func (s *PrimaryExpressionContext) TypeNameExpression() ITypeNameExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameExpressionContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}




func (p *SolidityParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	this := p
	_ = this

	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SolidityParserRULE_primaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(805)
			p.Match(SolidityParserBooleanLiteral)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(806)
			p.NumberLiteral()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(807)
			p.HexLiteral()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(808)
			p.StringLiteral()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(809)
			p.Identifier()
		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(810)
				p.Match(SolidityParserT__32)
			}
			{
				p.SetState(811)
				p.Match(SolidityParserT__33)
			}


		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(814)
			p.Match(SolidityParserTypeKeyword)
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(815)
			p.TupleExpression()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(816)
			p.TypeNameExpression()
		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(817)
				p.Match(SolidityParserT__32)
			}
			{
				p.SetState(818)
				p.Match(SolidityParserT__33)
			}


		}

	}


	return localctx
}


// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitExpressionList(s)
	}
}




func (p *SolidityParser) ExpressionList() (localctx IExpressionListContext) {
	this := p
	_ = this

	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SolidityParserRULE_expressionList)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		p.expression(0)
	}
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == SolidityParserT__14 {
		{
			p.SetState(824)
			p.Match(SolidityParserT__14)
		}
		{
			p.SetState(825)
			p.expression(0)
		}


		p.SetState(830)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// INameValueListContext is an interface to support dynamic dispatch.
type INameValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameValueListContext differentiates from other interfaces.
	IsNameValueListContext()
}

type NameValueListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameValueListContext() *NameValueListContext {
	var p = new(NameValueListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_nameValueList
	return p
}

func (*NameValueListContext) IsNameValueListContext() {}

func NewNameValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameValueListContext {
	var p = new(NameValueListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_nameValueList

	return p
}

func (s *NameValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *NameValueListContext) AllNameValue() []INameValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameValueContext); ok {
			len++
		}
	}

	tst := make([]INameValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameValueContext); ok {
			tst[i] = t.(INameValueContext)
			i++
		}
	}

	return tst
}

func (s *NameValueListContext) NameValue(i int) INameValueContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameValueContext)
}

func (s *NameValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NameValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterNameValueList(s)
	}
}

func (s *NameValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitNameValueList(s)
	}
}




func (p *SolidityParser) NameValueList() (localctx INameValueListContext) {
	this := p
	_ = this

	localctx = NewNameValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SolidityParserRULE_nameValueList)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(831)
		p.NameValue()
	}
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(832)
				p.Match(SolidityParserT__14)
			}
			{
				p.SetState(833)
				p.NameValue()
			}


		}
		p.SetState(838)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())
	}
	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__14 {
		{
			p.SetState(839)
			p.Match(SolidityParserT__14)
		}

	}



	return localctx
}


// INameValueContext is an interface to support dynamic dispatch.
type INameValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameValueContext differentiates from other interfaces.
	IsNameValueContext()
}

type NameValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameValueContext() *NameValueContext {
	var p = new(NameValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_nameValue
	return p
}

func (*NameValueContext) IsNameValueContext() {}

func NewNameValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameValueContext {
	var p = new(NameValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_nameValue

	return p
}

func (s *NameValueContext) GetParser() antlr.Parser { return s.parser }

func (s *NameValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NameValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NameValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NameValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterNameValue(s)
	}
}

func (s *NameValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitNameValue(s)
	}
}




func (p *SolidityParser) NameValue() (localctx INameValueContext) {
	this := p
	_ = this

	localctx = NewNameValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SolidityParserRULE_nameValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(842)
		p.Identifier()
	}
	{
		p.SetState(843)
		p.Match(SolidityParserT__58)
	}
	{
		p.SetState(844)
		p.expression(0)
	}



	return localctx
}


// IFunctionCallArgumentsContext is an interface to support dynamic dispatch.
type IFunctionCallArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallArgumentsContext differentiates from other interfaces.
	IsFunctionCallArgumentsContext()
}

type FunctionCallArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallArgumentsContext() *FunctionCallArgumentsContext {
	var p = new(FunctionCallArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_functionCallArguments
	return p
}

func (*FunctionCallArgumentsContext) IsFunctionCallArgumentsContext() {}

func NewFunctionCallArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallArgumentsContext {
	var p = new(FunctionCallArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionCallArguments

	return p
}

func (s *FunctionCallArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallArgumentsContext) NameValueList() INameValueListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameValueListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameValueListContext)
}

func (s *FunctionCallArgumentsContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *FunctionCallArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionCallArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionCallArguments(s)
	}
}

func (s *FunctionCallArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionCallArguments(s)
	}
}




func (p *SolidityParser) FunctionCallArguments() (localctx IFunctionCallArgumentsContext) {
	this := p
	_ = this

	localctx = NewFunctionCallArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SolidityParserRULE_functionCallArguments)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(854)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__13:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(846)
			p.Match(SolidityParserT__13)
		}
		p.SetState(848)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == SolidityParserT__12 || _la == SolidityParserT__39 || _la == SolidityParserT__51 || _la == SolidityParserIdentifier {
			{
				p.SetState(847)
				p.NameValueList()
			}

		}
		{
			p.SetState(850)
			p.Match(SolidityParserT__15)
		}


	case SolidityParserT__3, SolidityParserT__12, SolidityParserT__21, SolidityParserT__22, SolidityParserT__32, SolidityParserT__39, SolidityParserT__50, SolidityParserT__51, SolidityParserT__52, SolidityParserT__53, SolidityParserT__54, SolidityParserT__55, SolidityParserT__56, SolidityParserT__57, SolidityParserT__59, SolidityParserT__60, SolidityParserT__61, SolidityParserT__62, SolidityParserT__63, SolidityParserInt, SolidityParserUint, SolidityParserByte, SolidityParserFixed, SolidityParserUfixed, SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserPayableKeyword, SolidityParserTypeKeyword, SolidityParserIdentifier, SolidityParserStringLiteralFragment:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(852)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__21))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
			{
				p.SetState(851)
				p.ExpressionList()
			}

		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallContext) FunctionCallArguments() IFunctionCallArgumentsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallArgumentsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallArgumentsContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}




func (p *SolidityParser) FunctionCall() (localctx IFunctionCallContext) {
	this := p
	_ = this

	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SolidityParserRULE_functionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(856)
		p.expression(0)
	}
	{
		p.SetState(857)
		p.Match(SolidityParserT__21)
	}
	{
		p.SetState(858)
		p.FunctionCallArguments()
	}
	{
		p.SetState(859)
		p.Match(SolidityParserT__22)
	}



	return localctx
}


// ITupleExpressionContext is an interface to support dynamic dispatch.
type ITupleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTupleExpressionContext differentiates from other interfaces.
	IsTupleExpressionContext()
}

type TupleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleExpressionContext() *TupleExpressionContext {
	var p = new(TupleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_tupleExpression
	return p
}

func (*TupleExpressionContext) IsTupleExpressionContext() {}

func NewTupleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleExpressionContext {
	var p = new(TupleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_tupleExpression

	return p
}

func (s *TupleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TupleExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TupleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterTupleExpression(s)
	}
}

func (s *TupleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitTupleExpression(s)
	}
}




func (p *SolidityParser) TupleExpression() (localctx ITupleExpressionContext) {
	this := p
	_ = this

	localctx = NewTupleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SolidityParserRULE_tupleExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(887)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__21:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(861)
			p.Match(SolidityParserT__21)
		}

		p.SetState(863)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__21))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
			{
				p.SetState(862)
				p.expression(0)
			}

		}
		p.SetState(871)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == SolidityParserT__14 {
			{
				p.SetState(865)
				p.Match(SolidityParserT__14)
			}
			p.SetState(867)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__21))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
				{
					p.SetState(866)
					p.expression(0)
				}

			}


			p.SetState(873)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(874)
			p.Match(SolidityParserT__22)
		}


	case SolidityParserT__32:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(875)
			p.Match(SolidityParserT__32)
		}
		p.SetState(884)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__3) | (1 << SolidityParserT__12) | (1 << SolidityParserT__21))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (SolidityParserT__32 - 33)) | (1 << (SolidityParserT__39 - 33)) | (1 << (SolidityParserT__50 - 33)) | (1 << (SolidityParserT__51 - 33)) | (1 << (SolidityParserT__52 - 33)) | (1 << (SolidityParserT__53 - 33)) | (1 << (SolidityParserT__54 - 33)) | (1 << (SolidityParserT__55 - 33)) | (1 << (SolidityParserT__56 - 33)) | (1 << (SolidityParserT__57 - 33)) | (1 << (SolidityParserT__59 - 33)) | (1 << (SolidityParserT__60 - 33)) | (1 << (SolidityParserT__61 - 33)) | (1 << (SolidityParserT__62 - 33)) | (1 << (SolidityParserT__63 - 33)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (SolidityParserInt - 93)) | (1 << (SolidityParserUint - 93)) | (1 << (SolidityParserByte - 93)) | (1 << (SolidityParserFixed - 93)) | (1 << (SolidityParserUfixed - 93)) | (1 << (SolidityParserBooleanLiteral - 93)) | (1 << (SolidityParserDecimalNumber - 93)) | (1 << (SolidityParserHexNumber - 93)) | (1 << (SolidityParserHexLiteralFragment - 93)) | (1 << (SolidityParserPayableKeyword - 93)) | (1 << (SolidityParserTypeKeyword - 93)) | (1 << (SolidityParserIdentifier - 93)) | (1 << (SolidityParserStringLiteralFragment - 93)))) != 0) {
			{
				p.SetState(876)
				p.expression(0)
			}
			p.SetState(881)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			for _la == SolidityParserT__14 {
				{
					p.SetState(877)
					p.Match(SolidityParserT__14)
				}
				{
					p.SetState(878)
					p.expression(0)
				}


				p.SetState(883)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(886)
			p.Match(SolidityParserT__33)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ITypeNameExpressionContext is an interface to support dynamic dispatch.
type ITypeNameExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNameExpressionContext differentiates from other interfaces.
	IsTypeNameExpressionContext()
}

type TypeNameExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameExpressionContext() *TypeNameExpressionContext {
	var p = new(TypeNameExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_typeNameExpression
	return p
}

func (*TypeNameExpressionContext) IsTypeNameExpressionContext() {}

func NewTypeNameExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameExpressionContext {
	var p = new(TypeNameExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_typeNameExpression

	return p
}

func (s *TypeNameExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameExpressionContext) ElementaryTypeName() IElementaryTypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementaryTypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementaryTypeNameContext)
}

func (s *TypeNameExpressionContext) UserDefinedTypeName() IUserDefinedTypeNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDefinedTypeNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDefinedTypeNameContext)
}

func (s *TypeNameExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeNameExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterTypeNameExpression(s)
	}
}

func (s *TypeNameExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitTypeNameExpression(s)
	}
}




func (p *SolidityParser) TypeNameExpression() (localctx ITypeNameExpressionContext) {
	this := p
	_ = this

	localctx = NewTypeNameExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SolidityParserRULE_typeNameExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(891)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(889)
			p.ElementaryTypeName()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(890)
			p.UserDefinedTypeName()
		}

	}


	return localctx
}


// IAssemblyItemContext is an interface to support dynamic dispatch.
type IAssemblyItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyItemContext differentiates from other interfaces.
	IsAssemblyItemContext()
}

type AssemblyItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyItemContext() *AssemblyItemContext {
	var p = new(AssemblyItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyItem
	return p
}

func (*AssemblyItemContext) IsAssemblyItemContext() {}

func NewAssemblyItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyItemContext {
	var p = new(AssemblyItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyItem

	return p
}

func (s *AssemblyItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyItemContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyItemContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyItemContext) AssemblyLocalDefinition() IAssemblyLocalDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyLocalDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyLocalDefinitionContext)
}

func (s *AssemblyItemContext) AssemblyAssignment() IAssemblyAssignmentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyAssignmentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyAssignmentContext)
}

func (s *AssemblyItemContext) AssemblyStackAssignment() IAssemblyStackAssignmentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyStackAssignmentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyStackAssignmentContext)
}

func (s *AssemblyItemContext) LabelDefinition() ILabelDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDefinitionContext)
}

func (s *AssemblyItemContext) AssemblySwitch() IAssemblySwitchContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblySwitchContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblySwitchContext)
}

func (s *AssemblyItemContext) AssemblyFunctionDefinition() IAssemblyFunctionDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyFunctionDefinitionContext)
}

func (s *AssemblyItemContext) AssemblyFor() IAssemblyForContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyForContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyForContext)
}

func (s *AssemblyItemContext) AssemblyIf() IAssemblyIfContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIfContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIfContext)
}

func (s *AssemblyItemContext) BreakKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserBreakKeyword, 0)
}

func (s *AssemblyItemContext) ContinueKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserContinueKeyword, 0)
}

func (s *AssemblyItemContext) LeaveKeyword() antlr.TerminalNode {
	return s.GetToken(SolidityParserLeaveKeyword, 0)
}

func (s *AssemblyItemContext) SubAssembly() ISubAssemblyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubAssemblyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubAssemblyContext)
}

func (s *AssemblyItemContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *AssemblyItemContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AssemblyItemContext) HexLiteral() IHexLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexLiteralContext)
}

func (s *AssemblyItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyItem(s)
	}
}

func (s *AssemblyItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyItem(s)
	}
}




func (p *SolidityParser) AssemblyItem() (localctx IAssemblyItemContext) {
	this := p
	_ = this

	localctx = NewAssemblyItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SolidityParserRULE_assemblyItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(893)
			p.Identifier()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(894)
			p.AssemblyBlock()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(895)
			p.AssemblyExpression()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(896)
			p.AssemblyLocalDefinition()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(897)
			p.AssemblyAssignment()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(898)
			p.AssemblyStackAssignment()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(899)
			p.LabelDefinition()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(900)
			p.AssemblySwitch()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(901)
			p.AssemblyFunctionDefinition()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(902)
			p.AssemblyFor()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(903)
			p.AssemblyIf()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(904)
			p.Match(SolidityParserBreakKeyword)
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(905)
			p.Match(SolidityParserContinueKeyword)
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(906)
			p.Match(SolidityParserLeaveKeyword)
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(907)
			p.SubAssembly()
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(908)
			p.NumberLiteral()
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(909)
			p.StringLiteral()
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(910)
			p.HexLiteral()
		}

	}


	return localctx
}


// IAssemblyBlockContext is an interface to support dynamic dispatch.
type IAssemblyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyBlockContext differentiates from other interfaces.
	IsAssemblyBlockContext()
}

type AssemblyBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyBlockContext() *AssemblyBlockContext {
	var p = new(AssemblyBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyBlock
	return p
}

func (*AssemblyBlockContext) IsAssemblyBlockContext() {}

func NewAssemblyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyBlockContext {
	var p = new(AssemblyBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyBlock

	return p
}

func (s *AssemblyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyBlockContext) AllAssemblyItem() []IAssemblyItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyItemContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyItemContext); ok {
			tst[i] = t.(IAssemblyItemContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyBlockContext) AssemblyItem(i int) IAssemblyItemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyItemContext)
}

func (s *AssemblyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyBlock(s)
	}
}

func (s *AssemblyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyBlock(s)
	}
}




func (p *SolidityParser) AssemblyBlock() (localctx IAssemblyBlockContext) {
	this := p
	_ = this

	localctx = NewAssemblyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SolidityParserRULE_assemblyBlock)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(913)
		p.Match(SolidityParserT__13)
	}
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << SolidityParserT__12) | (1 << SolidityParserT__13) | (1 << SolidityParserT__25) | (1 << SolidityParserT__28))) != 0) || ((((_la - 40)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 40))) & ((1 << (SolidityParserT__39 - 40)) | (1 << (SolidityParserT__40 - 40)) | (1 << (SolidityParserT__45 - 40)) | (1 << (SolidityParserT__47 - 40)) | (1 << (SolidityParserT__51 - 40)) | (1 << (SolidityParserT__54 - 40)))) != 0) || ((((_la - 87)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 87))) & ((1 << (SolidityParserT__86 - 87)) | (1 << (SolidityParserT__88 - 87)) | (1 << (SolidityParserT__89 - 87)) | (1 << (SolidityParserBooleanLiteral - 87)) | (1 << (SolidityParserDecimalNumber - 87)) | (1 << (SolidityParserHexNumber - 87)) | (1 << (SolidityParserHexLiteralFragment - 87)) | (1 << (SolidityParserBreakKeyword - 87)) | (1 << (SolidityParserContinueKeyword - 87)) | (1 << (SolidityParserLeaveKeyword - 87)))) != 0) || _la == SolidityParserIdentifier || _la == SolidityParserStringLiteralFragment {
		{
			p.SetState(914)
			p.AssemblyItem()
		}


		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(920)
		p.Match(SolidityParserT__15)
	}



	return localctx
}


// IAssemblyExpressionContext is an interface to support dynamic dispatch.
type IAssemblyExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyExpressionContext differentiates from other interfaces.
	IsAssemblyExpressionContext()
}

type AssemblyExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyExpressionContext() *AssemblyExpressionContext {
	var p = new(AssemblyExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyExpression
	return p
}

func (*AssemblyExpressionContext) IsAssemblyExpressionContext() {}

func NewAssemblyExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyExpressionContext {
	var p = new(AssemblyExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyExpression

	return p
}

func (s *AssemblyExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyExpressionContext) AssemblyCall() IAssemblyCallContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyCallContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyCallContext)
}

func (s *AssemblyExpressionContext) AssemblyLiteral() IAssemblyLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyLiteralContext)
}

func (s *AssemblyExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyExpression(s)
	}
}

func (s *AssemblyExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyExpression(s)
	}
}




func (p *SolidityParser) AssemblyExpression() (localctx IAssemblyExpressionContext) {
	this := p
	_ = this

	localctx = NewAssemblyExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SolidityParserRULE_assemblyExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(924)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__12, SolidityParserT__39, SolidityParserT__47, SolidityParserT__51, SolidityParserT__54, SolidityParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(922)
			p.AssemblyCall()
		}


	case SolidityParserBooleanLiteral, SolidityParserDecimalNumber, SolidityParserHexNumber, SolidityParserHexLiteralFragment, SolidityParserStringLiteralFragment:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(923)
			p.AssemblyLiteral()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IAssemblyCallContext is an interface to support dynamic dispatch.
type IAssemblyCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyCallContext differentiates from other interfaces.
	IsAssemblyCallContext()
}

type AssemblyCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyCallContext() *AssemblyCallContext {
	var p = new(AssemblyCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyCall
	return p
}

func (*AssemblyCallContext) IsAssemblyCallContext() {}

func NewAssemblyCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyCallContext {
	var p = new(AssemblyCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyCall

	return p
}

func (s *AssemblyCallContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyCallContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyCallContext) AllAssemblyExpression() []IAssemblyExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyExpressionContext); ok {
			tst[i] = t.(IAssemblyExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyCallContext) AssemblyExpression(i int) IAssemblyExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyCall(s)
	}
}

func (s *AssemblyCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyCall(s)
	}
}




func (p *SolidityParser) AssemblyCall() (localctx IAssemblyCallContext) {
	this := p
	_ = this

	localctx = NewAssemblyCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SolidityParserRULE_assemblyCall)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(930)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(926)
			p.Match(SolidityParserT__47)
		}


	case 2:
		{
			p.SetState(927)
			p.Match(SolidityParserT__51)
		}


	case 3:
		{
			p.SetState(928)
			p.Match(SolidityParserT__54)
		}


	case 4:
		{
			p.SetState(929)
			p.Identifier()
		}

	}
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__21 {
		{
			p.SetState(932)
			p.Match(SolidityParserT__21)
		}
		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == SolidityParserT__12 || ((((_la - 40)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 40))) & ((1 << (SolidityParserT__39 - 40)) | (1 << (SolidityParserT__47 - 40)) | (1 << (SolidityParserT__51 - 40)) | (1 << (SolidityParserT__54 - 40)))) != 0) || ((((_la - 98)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 98))) & ((1 << (SolidityParserBooleanLiteral - 98)) | (1 << (SolidityParserDecimalNumber - 98)) | (1 << (SolidityParserHexNumber - 98)) | (1 << (SolidityParserHexLiteralFragment - 98)) | (1 << (SolidityParserIdentifier - 98)) | (1 << (SolidityParserStringLiteralFragment - 98)))) != 0) {
			{
				p.SetState(933)
				p.AssemblyExpression()
			}

		}
		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == SolidityParserT__14 {
			{
				p.SetState(936)
				p.Match(SolidityParserT__14)
			}
			{
				p.SetState(937)
				p.AssemblyExpression()
			}


			p.SetState(942)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(943)
			p.Match(SolidityParserT__22)
		}

	}



	return localctx
}


// IAssemblyLocalDefinitionContext is an interface to support dynamic dispatch.
type IAssemblyLocalDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyLocalDefinitionContext differentiates from other interfaces.
	IsAssemblyLocalDefinitionContext()
}

type AssemblyLocalDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyLocalDefinitionContext() *AssemblyLocalDefinitionContext {
	var p = new(AssemblyLocalDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyLocalDefinition
	return p
}

func (*AssemblyLocalDefinitionContext) IsAssemblyLocalDefinitionContext() {}

func NewAssemblyLocalDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyLocalDefinitionContext {
	var p = new(AssemblyLocalDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyLocalDefinition

	return p
}

func (s *AssemblyLocalDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyLocalDefinitionContext) AssemblyIdentifierList() IAssemblyIdentifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIdentifierListContext)
}

func (s *AssemblyLocalDefinitionContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyLocalDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyLocalDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyLocalDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyLocalDefinition(s)
	}
}

func (s *AssemblyLocalDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyLocalDefinition(s)
	}
}




func (p *SolidityParser) AssemblyLocalDefinition() (localctx IAssemblyLocalDefinitionContext) {
	this := p
	_ = this

	localctx = NewAssemblyLocalDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SolidityParserRULE_assemblyLocalDefinition)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(946)
		p.Match(SolidityParserT__86)
	}
	{
		p.SetState(947)
		p.AssemblyIdentifierList()
	}
	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__87 {
		{
			p.SetState(948)
			p.Match(SolidityParserT__87)
		}
		{
			p.SetState(949)
			p.AssemblyExpression()
		}

	}



	return localctx
}


// IAssemblyAssignmentContext is an interface to support dynamic dispatch.
type IAssemblyAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyAssignmentContext differentiates from other interfaces.
	IsAssemblyAssignmentContext()
}

type AssemblyAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyAssignmentContext() *AssemblyAssignmentContext {
	var p = new(AssemblyAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyAssignment
	return p
}

func (*AssemblyAssignmentContext) IsAssemblyAssignmentContext() {}

func NewAssemblyAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyAssignmentContext {
	var p = new(AssemblyAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyAssignment

	return p
}

func (s *AssemblyAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyAssignmentContext) AssemblyIdentifierList() IAssemblyIdentifierListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyIdentifierListContext)
}

func (s *AssemblyAssignmentContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyAssignment(s)
	}
}

func (s *AssemblyAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyAssignment(s)
	}
}




func (p *SolidityParser) AssemblyAssignment() (localctx IAssemblyAssignmentContext) {
	this := p
	_ = this

	localctx = NewAssemblyAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SolidityParserRULE_assemblyAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(952)
		p.AssemblyIdentifierList()
	}
	{
		p.SetState(953)
		p.Match(SolidityParserT__87)
	}
	{
		p.SetState(954)
		p.AssemblyExpression()
	}



	return localctx
}


// IAssemblyIdentifierListContext is an interface to support dynamic dispatch.
type IAssemblyIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyIdentifierListContext differentiates from other interfaces.
	IsAssemblyIdentifierListContext()
}

type AssemblyIdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyIdentifierListContext() *AssemblyIdentifierListContext {
	var p = new(AssemblyIdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyIdentifierList
	return p
}

func (*AssemblyIdentifierListContext) IsAssemblyIdentifierListContext() {}

func NewAssemblyIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyIdentifierListContext {
	var p = new(AssemblyIdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyIdentifierList

	return p
}

func (s *AssemblyIdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyIdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyIdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyIdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyIdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyIdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyIdentifierList(s)
	}
}

func (s *AssemblyIdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyIdentifierList(s)
	}
}




func (p *SolidityParser) AssemblyIdentifierList() (localctx IAssemblyIdentifierListContext) {
	this := p
	_ = this

	localctx = NewAssemblyIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SolidityParserRULE_assemblyIdentifierList)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(956)
		p.Identifier()
	}
	p.SetState(961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == SolidityParserT__14 {
		{
			p.SetState(957)
			p.Match(SolidityParserT__14)
		}
		{
			p.SetState(958)
			p.Identifier()
		}


		p.SetState(963)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAssemblyStackAssignmentContext is an interface to support dynamic dispatch.
type IAssemblyStackAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyStackAssignmentContext differentiates from other interfaces.
	IsAssemblyStackAssignmentContext()
}

type AssemblyStackAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyStackAssignmentContext() *AssemblyStackAssignmentContext {
	var p = new(AssemblyStackAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyStackAssignment
	return p
}

func (*AssemblyStackAssignmentContext) IsAssemblyStackAssignmentContext() {}

func NewAssemblyStackAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyStackAssignmentContext {
	var p = new(AssemblyStackAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyStackAssignment

	return p
}

func (s *AssemblyStackAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyStackAssignmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyStackAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyStackAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyStackAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyStackAssignment(s)
	}
}

func (s *AssemblyStackAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyStackAssignment(s)
	}
}




func (p *SolidityParser) AssemblyStackAssignment() (localctx IAssemblyStackAssignmentContext) {
	this := p
	_ = this

	localctx = NewAssemblyStackAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SolidityParserRULE_assemblyStackAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(964)
		p.Match(SolidityParserT__88)
	}
	{
		p.SetState(965)
		p.Identifier()
	}



	return localctx
}


// ILabelDefinitionContext is an interface to support dynamic dispatch.
type ILabelDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelDefinitionContext differentiates from other interfaces.
	IsLabelDefinitionContext()
}

type LabelDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelDefinitionContext() *LabelDefinitionContext {
	var p = new(LabelDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_labelDefinition
	return p
}

func (*LabelDefinitionContext) IsLabelDefinitionContext() {}

func NewLabelDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelDefinitionContext {
	var p = new(LabelDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_labelDefinition

	return p
}

func (s *LabelDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabelDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LabelDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterLabelDefinition(s)
	}
}

func (s *LabelDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitLabelDefinition(s)
	}
}




func (p *SolidityParser) LabelDefinition() (localctx ILabelDefinitionContext) {
	this := p
	_ = this

	localctx = NewLabelDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SolidityParserRULE_labelDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(967)
		p.Identifier()
	}
	{
		p.SetState(968)
		p.Match(SolidityParserT__58)
	}



	return localctx
}


// IAssemblySwitchContext is an interface to support dynamic dispatch.
type IAssemblySwitchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblySwitchContext differentiates from other interfaces.
	IsAssemblySwitchContext()
}

type AssemblySwitchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblySwitchContext() *AssemblySwitchContext {
	var p = new(AssemblySwitchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblySwitch
	return p
}

func (*AssemblySwitchContext) IsAssemblySwitchContext() {}

func NewAssemblySwitchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblySwitchContext {
	var p = new(AssemblySwitchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblySwitch

	return p
}

func (s *AssemblySwitchContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblySwitchContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblySwitchContext) AllAssemblyCase() []IAssemblyCaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyCaseContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyCaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyCaseContext); ok {
			tst[i] = t.(IAssemblyCaseContext)
			i++
		}
	}

	return tst
}

func (s *AssemblySwitchContext) AssemblyCase(i int) IAssemblyCaseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyCaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyCaseContext)
}

func (s *AssemblySwitchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblySwitchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblySwitchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblySwitch(s)
	}
}

func (s *AssemblySwitchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblySwitch(s)
	}
}




func (p *SolidityParser) AssemblySwitch() (localctx IAssemblySwitchContext) {
	this := p
	_ = this

	localctx = NewAssemblySwitchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SolidityParserRULE_assemblySwitch)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(970)
		p.Match(SolidityParserT__89)
	}
	{
		p.SetState(971)
		p.AssemblyExpression()
	}
	p.SetState(975)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == SolidityParserT__90 || _la == SolidityParserT__91 {
		{
			p.SetState(972)
			p.AssemblyCase()
		}


		p.SetState(977)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAssemblyCaseContext is an interface to support dynamic dispatch.
type IAssemblyCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyCaseContext differentiates from other interfaces.
	IsAssemblyCaseContext()
}

type AssemblyCaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyCaseContext() *AssemblyCaseContext {
	var p = new(AssemblyCaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyCase
	return p
}

func (*AssemblyCaseContext) IsAssemblyCaseContext() {}

func NewAssemblyCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyCaseContext {
	var p = new(AssemblyCaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyCase

	return p
}

func (s *AssemblyCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyCaseContext) AssemblyLiteral() IAssemblyLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyLiteralContext)
}

func (s *AssemblyCaseContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyCaseContext) AssemblyType() IAssemblyTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyTypeContext)
}

func (s *AssemblyCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyCase(s)
	}
}

func (s *AssemblyCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyCase(s)
	}
}




func (p *SolidityParser) AssemblyCase() (localctx IAssemblyCaseContext) {
	this := p
	_ = this

	localctx = NewAssemblyCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SolidityParserRULE_assemblyCase)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(987)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserT__90:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(978)
			p.Match(SolidityParserT__90)
		}
		{
			p.SetState(979)
			p.AssemblyLiteral()
		}
		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == SolidityParserT__58 {
			{
				p.SetState(980)
				p.AssemblyType()
			}

		}
		{
			p.SetState(983)
			p.AssemblyBlock()
		}


	case SolidityParserT__91:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(985)
			p.Match(SolidityParserT__91)
		}
		{
			p.SetState(986)
			p.AssemblyBlock()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IAssemblyFunctionDefinitionContext is an interface to support dynamic dispatch.
type IAssemblyFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyFunctionDefinitionContext differentiates from other interfaces.
	IsAssemblyFunctionDefinitionContext()
}

type AssemblyFunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyFunctionDefinitionContext() *AssemblyFunctionDefinitionContext {
	var p = new(AssemblyFunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFunctionDefinition
	return p
}

func (*AssemblyFunctionDefinitionContext) IsAssemblyFunctionDefinitionContext() {}

func NewAssemblyFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyFunctionDefinitionContext {
	var p = new(AssemblyFunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyFunctionDefinition

	return p
}

func (s *AssemblyFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyFunctionDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyFunctionDefinitionContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyFunctionDefinitionContext) AssemblyTypedVariableList() IAssemblyTypedVariableListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyTypedVariableListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyTypedVariableListContext)
}

func (s *AssemblyFunctionDefinitionContext) AssemblyFunctionReturns() IAssemblyFunctionReturnsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyFunctionReturnsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyFunctionReturnsContext)
}

func (s *AssemblyFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyFunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyFunctionDefinition(s)
	}
}

func (s *AssemblyFunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyFunctionDefinition(s)
	}
}




func (p *SolidityParser) AssemblyFunctionDefinition() (localctx IAssemblyFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewAssemblyFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SolidityParserRULE_assemblyFunctionDefinition)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(989)
		p.Match(SolidityParserT__28)
	}
	{
		p.SetState(990)
		p.Identifier()
	}
	{
		p.SetState(991)
		p.Match(SolidityParserT__21)
	}
	p.SetState(993)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__12 || _la == SolidityParserT__39 || _la == SolidityParserT__51 || _la == SolidityParserIdentifier {
		{
			p.SetState(992)
			p.AssemblyTypedVariableList()
		}

	}
	{
		p.SetState(995)
		p.Match(SolidityParserT__22)
	}
	p.SetState(997)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__60 {
		{
			p.SetState(996)
			p.AssemblyFunctionReturns()
		}

	}
	{
		p.SetState(999)
		p.AssemblyBlock()
	}



	return localctx
}


// IAssemblyFunctionReturnsContext is an interface to support dynamic dispatch.
type IAssemblyFunctionReturnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyFunctionReturnsContext differentiates from other interfaces.
	IsAssemblyFunctionReturnsContext()
}

type AssemblyFunctionReturnsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyFunctionReturnsContext() *AssemblyFunctionReturnsContext {
	var p = new(AssemblyFunctionReturnsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFunctionReturns
	return p
}

func (*AssemblyFunctionReturnsContext) IsAssemblyFunctionReturnsContext() {}

func NewAssemblyFunctionReturnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyFunctionReturnsContext {
	var p = new(AssemblyFunctionReturnsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyFunctionReturns

	return p
}

func (s *AssemblyFunctionReturnsContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyFunctionReturnsContext) AssemblyTypedVariableList() IAssemblyTypedVariableListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyTypedVariableListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyTypedVariableListContext)
}

func (s *AssemblyFunctionReturnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyFunctionReturnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyFunctionReturnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyFunctionReturns(s)
	}
}

func (s *AssemblyFunctionReturnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyFunctionReturns(s)
	}
}




func (p *SolidityParser) AssemblyFunctionReturns() (localctx IAssemblyFunctionReturnsContext) {
	this := p
	_ = this

	localctx = NewAssemblyFunctionReturnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SolidityParserRULE_assemblyFunctionReturns)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1001)
		p.Match(SolidityParserT__60)
	}
	{
		p.SetState(1002)
		p.Match(SolidityParserT__5)
	}
	{
		p.SetState(1003)
		p.AssemblyTypedVariableList()
	}




	return localctx
}


// IAssemblyForContext is an interface to support dynamic dispatch.
type IAssemblyForContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyForContext differentiates from other interfaces.
	IsAssemblyForContext()
}

type AssemblyForContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyForContext() *AssemblyForContext {
	var p = new(AssemblyForContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyFor
	return p
}

func (*AssemblyForContext) IsAssemblyForContext() {}

func NewAssemblyForContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyForContext {
	var p = new(AssemblyForContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyFor

	return p
}

func (s *AssemblyForContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyForContext) AllAssemblyBlock() []IAssemblyBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			len++
		}
	}

	tst := make([]IAssemblyBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssemblyBlockContext); ok {
			tst[i] = t.(IAssemblyBlockContext)
			i++
		}
	}

	return tst
}

func (s *AssemblyForContext) AssemblyBlock(i int) IAssemblyBlockContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyForContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyForContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyFor(s)
	}
}

func (s *AssemblyForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyFor(s)
	}
}




func (p *SolidityParser) AssemblyFor() (localctx IAssemblyForContext) {
	this := p
	_ = this

	localctx = NewAssemblyForContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SolidityParserRULE_assemblyFor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1005)
		p.Match(SolidityParserT__25)
	}
	{
		p.SetState(1006)
		p.AssemblyBlock()
	}
	{
		p.SetState(1007)
		p.AssemblyExpression()
	}
	{
		p.SetState(1008)
		p.AssemblyBlock()
	}
	{
		p.SetState(1009)
		p.AssemblyBlock()
	}



	return localctx
}


// IAssemblyIfContext is an interface to support dynamic dispatch.
type IAssemblyIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyIfContext differentiates from other interfaces.
	IsAssemblyIfContext()
}

type AssemblyIfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyIfContext() *AssemblyIfContext {
	var p = new(AssemblyIfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyIf
	return p
}

func (*AssemblyIfContext) IsAssemblyIfContext() {}

func NewAssemblyIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyIfContext {
	var p = new(AssemblyIfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyIf

	return p
}

func (s *AssemblyIfContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyIfContext) AssemblyExpression() IAssemblyExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyExpressionContext)
}

func (s *AssemblyIfContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *AssemblyIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyIf(s)
	}
}

func (s *AssemblyIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyIf(s)
	}
}




func (p *SolidityParser) AssemblyIf() (localctx IAssemblyIfContext) {
	this := p
	_ = this

	localctx = NewAssemblyIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SolidityParserRULE_assemblyIf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)
		p.Match(SolidityParserT__40)
	}
	{
		p.SetState(1012)
		p.AssemblyExpression()
	}
	{
		p.SetState(1013)
		p.AssemblyBlock()
	}



	return localctx
}


// IAssemblyLiteralContext is an interface to support dynamic dispatch.
type IAssemblyLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyLiteralContext differentiates from other interfaces.
	IsAssemblyLiteralContext()
}

type AssemblyLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyLiteralContext() *AssemblyLiteralContext {
	var p = new(AssemblyLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyLiteral
	return p
}

func (*AssemblyLiteralContext) IsAssemblyLiteralContext() {}

func NewAssemblyLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyLiteralContext {
	var p = new(AssemblyLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyLiteral

	return p
}

func (s *AssemblyLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyLiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AssemblyLiteralContext) DecimalNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserDecimalNumber, 0)
}

func (s *AssemblyLiteralContext) HexNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserHexNumber, 0)
}

func (s *AssemblyLiteralContext) HexLiteral() IHexLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexLiteralContext)
}

func (s *AssemblyLiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(SolidityParserBooleanLiteral, 0)
}

func (s *AssemblyLiteralContext) AssemblyType() IAssemblyTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyTypeContext)
}

func (s *AssemblyLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyLiteral(s)
	}
}

func (s *AssemblyLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyLiteral(s)
	}
}




func (p *SolidityParser) AssemblyLiteral() (localctx IAssemblyLiteralContext) {
	this := p
	_ = this

	localctx = NewAssemblyLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SolidityParserRULE_assemblyLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1020)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SolidityParserStringLiteralFragment:
		{
			p.SetState(1015)
			p.StringLiteral()
		}


	case SolidityParserDecimalNumber:
		{
			p.SetState(1016)
			p.Match(SolidityParserDecimalNumber)
		}


	case SolidityParserHexNumber:
		{
			p.SetState(1017)
			p.Match(SolidityParserHexNumber)
		}


	case SolidityParserHexLiteralFragment:
		{
			p.SetState(1018)
			p.HexLiteral()
		}


	case SolidityParserBooleanLiteral:
		{
			p.SetState(1019)
			p.Match(SolidityParserBooleanLiteral)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1022)
			p.AssemblyType()
		}


	}



	return localctx
}


// IAssemblyTypedVariableListContext is an interface to support dynamic dispatch.
type IAssemblyTypedVariableListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyTypedVariableListContext differentiates from other interfaces.
	IsAssemblyTypedVariableListContext()
}

type AssemblyTypedVariableListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyTypedVariableListContext() *AssemblyTypedVariableListContext {
	var p = new(AssemblyTypedVariableListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyTypedVariableList
	return p
}

func (*AssemblyTypedVariableListContext) IsAssemblyTypedVariableListContext() {}

func NewAssemblyTypedVariableListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyTypedVariableListContext {
	var p = new(AssemblyTypedVariableListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyTypedVariableList

	return p
}

func (s *AssemblyTypedVariableListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyTypedVariableListContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyTypedVariableListContext) AssemblyType() IAssemblyTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyTypeContext)
}

func (s *AssemblyTypedVariableListContext) AssemblyTypedVariableList() IAssemblyTypedVariableListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyTypedVariableListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyTypedVariableListContext)
}

func (s *AssemblyTypedVariableListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyTypedVariableListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyTypedVariableListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyTypedVariableList(s)
	}
}

func (s *AssemblyTypedVariableListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyTypedVariableList(s)
	}
}




func (p *SolidityParser) AssemblyTypedVariableList() (localctx IAssemblyTypedVariableListContext) {
	this := p
	_ = this

	localctx = NewAssemblyTypedVariableListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SolidityParserRULE_assemblyTypedVariableList)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1025)
		p.Identifier()
	}
	p.SetState(1027)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__58 {
		{
			p.SetState(1026)
			p.AssemblyType()
		}

	}
	p.SetState(1031)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == SolidityParserT__14 {
		{
			p.SetState(1029)
			p.Match(SolidityParserT__14)
		}
		{
			p.SetState(1030)
			p.AssemblyTypedVariableList()
		}

	}



	return localctx
}


// IAssemblyTypeContext is an interface to support dynamic dispatch.
type IAssemblyTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyTypeContext differentiates from other interfaces.
	IsAssemblyTypeContext()
}

type AssemblyTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyTypeContext() *AssemblyTypeContext {
	var p = new(AssemblyTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_assemblyType
	return p
}

func (*AssemblyTypeContext) IsAssemblyTypeContext() {}

func NewAssemblyTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyTypeContext {
	var p = new(AssemblyTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_assemblyType

	return p
}

func (s *AssemblyTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssemblyTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssemblyTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterAssemblyType(s)
	}
}

func (s *AssemblyTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitAssemblyType(s)
	}
}




func (p *SolidityParser) AssemblyType() (localctx IAssemblyTypeContext) {
	this := p
	_ = this

	localctx = NewAssemblyTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SolidityParserRULE_assemblyType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1033)
		p.Match(SolidityParserT__58)
	}
	{
		p.SetState(1034)
		p.Identifier()
	}



	return localctx
}


// ISubAssemblyContext is an interface to support dynamic dispatch.
type ISubAssemblyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubAssemblyContext differentiates from other interfaces.
	IsSubAssemblyContext()
}

type SubAssemblyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubAssemblyContext() *SubAssemblyContext {
	var p = new(SubAssemblyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_subAssembly
	return p
}

func (*SubAssemblyContext) IsSubAssemblyContext() {}

func NewSubAssemblyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubAssemblyContext {
	var p = new(SubAssemblyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_subAssembly

	return p
}

func (s *SubAssemblyContext) GetParser() antlr.Parser { return s.parser }

func (s *SubAssemblyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubAssemblyContext) AssemblyBlock() IAssemblyBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblyBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblyBlockContext)
}

func (s *SubAssemblyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubAssemblyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubAssemblyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterSubAssembly(s)
	}
}

func (s *SubAssemblyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitSubAssembly(s)
	}
}




func (p *SolidityParser) SubAssembly() (localctx ISubAssemblyContext) {
	this := p
	_ = this

	localctx = NewSubAssemblyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SolidityParserRULE_subAssembly)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1036)
		p.Match(SolidityParserT__45)
	}
	{
		p.SetState(1037)
		p.Identifier()
	}
	{
		p.SetState(1038)
		p.AssemblyBlock()
	}



	return localctx
}


// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_numberLiteral
	return p
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) DecimalNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserDecimalNumber, 0)
}

func (s *NumberLiteralContext) HexNumber() antlr.TerminalNode {
	return s.GetToken(SolidityParserHexNumber, 0)
}

func (s *NumberLiteralContext) NumberUnit() antlr.TerminalNode {
	return s.GetToken(SolidityParserNumberUnit, 0)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}




func (p *SolidityParser) NumberLiteral() (localctx INumberLiteralContext) {
	this := p
	_ = this

	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SolidityParserRULE_numberLiteral)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1040)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SolidityParserDecimalNumber || _la == SolidityParserHexNumber) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1042)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1041)
			p.Match(SolidityParserNumberUnit)
		}


	}



	return localctx
}


// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(SolidityParserIdentifier, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitIdentifier(s)
	}
}




func (p *SolidityParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SolidityParserRULE_identifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1044)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SolidityParserT__12 || _la == SolidityParserT__39 || _la == SolidityParserT__51 || _la == SolidityParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IHexLiteralContext is an interface to support dynamic dispatch.
type IHexLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHexLiteralContext differentiates from other interfaces.
	IsHexLiteralContext()
}

type HexLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexLiteralContext() *HexLiteralContext {
	var p = new(HexLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_hexLiteral
	return p
}

func (*HexLiteralContext) IsHexLiteralContext() {}

func NewHexLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexLiteralContext {
	var p = new(HexLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_hexLiteral

	return p
}

func (s *HexLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexLiteralContext) AllHexLiteralFragment() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserHexLiteralFragment)
}

func (s *HexLiteralContext) HexLiteralFragment(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserHexLiteralFragment, i)
}

func (s *HexLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HexLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterHexLiteral(s)
	}
}

func (s *HexLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitHexLiteral(s)
	}
}




func (p *SolidityParser) HexLiteral() (localctx IHexLiteralContext) {
	this := p
	_ = this

	localctx = NewHexLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SolidityParserRULE_hexLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1047)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(1046)
					p.Match(SolidityParserHexLiteralFragment)
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1049)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext())
	}



	return localctx
}


// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SolidityParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SolidityParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllStringLiteralFragment() []antlr.TerminalNode {
	return s.GetTokens(SolidityParserStringLiteralFragment)
}

func (s *StringLiteralContext) StringLiteralFragment(i int) antlr.TerminalNode {
	return s.GetToken(SolidityParserStringLiteralFragment, i)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SolidityListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}




func (p *SolidityParser) StringLiteral() (localctx IStringLiteralContext) {
	this := p
	_ = this

	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SolidityParserRULE_stringLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1052)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(1051)
					p.Match(SolidityParserStringLiteralFragment)
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1054)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext())
	}



	return localctx
}


func (p *SolidityParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 30:
			var t *TypeNameContext = nil
			if localctx != nil { t = localctx.(*TypeNameContext) }
			return p.TypeName_Sempred(t, predIndex)

	case 56:
			var t *ExpressionContext = nil
			if localctx != nil { t = localctx.(*ExpressionContext) }
			return p.Expression_Sempred(t, predIndex)


	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SolidityParser) TypeName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
			return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SolidityParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
			return p.Precpred(p.GetParserRuleContext(), 14)

	case 2:
			return p.Precpred(p.GetParserRuleContext(), 13)

	case 3:
			return p.Precpred(p.GetParserRuleContext(), 12)

	case 4:
			return p.Precpred(p.GetParserRuleContext(), 11)

	case 5:
			return p.Precpred(p.GetParserRuleContext(), 10)

	case 6:
			return p.Precpred(p.GetParserRuleContext(), 9)

	case 7:
			return p.Precpred(p.GetParserRuleContext(), 8)

	case 8:
			return p.Precpred(p.GetParserRuleContext(), 7)

	case 9:
			return p.Precpred(p.GetParserRuleContext(), 6)

	case 10:
			return p.Precpred(p.GetParserRuleContext(), 5)

	case 11:
			return p.Precpred(p.GetParserRuleContext(), 4)

	case 12:
			return p.Precpred(p.GetParserRuleContext(), 3)

	case 13:
			return p.Precpred(p.GetParserRuleContext(), 2)

	case 14:
			return p.Precpred(p.GetParserRuleContext(), 28)

	case 15:
			return p.Precpred(p.GetParserRuleContext(), 26)

	case 16:
			return p.Precpred(p.GetParserRuleContext(), 25)

	case 17:
			return p.Precpred(p.GetParserRuleContext(), 24)

	case 18:
			return p.Precpred(p.GetParserRuleContext(), 23)

	case 19:
			return p.Precpred(p.GetParserRuleContext(), 22)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

